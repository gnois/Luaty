var term = require('term')
var compiler = require('lt.compile')
var color = term.color

var usage = \err ->
	var spec = ``
Usage: 
  luajit lt.lua [-f] [-c] [-t] [-d xvar] src.lt [dst]
  where:
    -c        Transpile src.lt and its dependecies into ./dst/src.lua, ./dst/*.lua ... without running
    -f        Transpile src.lt and its dependecies into ./dst/src.lua, ./dst/*.lua ... without running, overwriting them if they exist
    -t        Enable type checking
    -d xvar   Declares `xvar` to silent undeclared identifier warning
  
  dst specifies an output directory and must not end with .lt
  If it is empty, output files will reside in the same directory as source file.

  Running without parameters enters Read-Generate-Eval-Print loop
``
	err = err or ''
	err = err .. '\n' .. spec
	term.usage(err)


var run = true
var force = false
var already = false
var typecheck = false
var paths = {}
var decls = {}

for s, p in term.scan({...})
	if s == 'c' or s == 'f'
		if already
			usage("Error: use either -c or -f only")
		already = true
		run = false
		if s == 'f'
			force = true
		if p
			table.insert(paths, p)
	else if s == 'd'
		if p
			decls[p] = true
		else
			usage("Error: -d requires identifier")
	else if s == 't'
		typecheck = true
		if p
			table.insert(paths, p)
	else
		if s ~= ""
			usage("Error: unknown switch -" .. s)
		if p
			table.insert(paths, p)


var src, dst
if #paths > 2
	usage("Error: only one file with an optional output directory accepted")
else
	src = paths[1]
	dst = paths[2]
	if dst
		-- remove slashes at the end
		dst = string.gsub(dst, term.slash .. "*$", "")
		if string.sub(dst, -string.len(".lt")) == ".lt"
			usage("Error: " .. dst .. " as output directory cannot end with .lt")


var compile = compiler({declares = decls, typecheck = typecheck}, color)

if src
	var _, code, warns, imports = compile.file(src)
	if run
		if warns
			print(warns)
		if code
			var fn = assert(loadstring(code))
			fn()
		else
			print(" Fail to run " .. src)
	else
		var created = {}  -- folders created
		var existed = {}  -- folders already exist
		var skips = {}  -- files not overwritten or failed to compile
		for __, file in pairs(imports)
			print(file.path)
			if file.warns
				print(file.warns)

			-- construct output file path
			var dest = string.gsub(file.path, "%.lt", ".lua")
			if dst
				dest = dst .. term.slash .. dest
			-- dest is now dir/sub/file.lua
			if file.code
				-- split into dir/sub and file.lua
				var name = dest
				var dir
				string.gsub(dest, "(.*[/\\])(.*)", \d, n -> 
					dir = d
					name = n
				)
				-- no need to test against overwrite if dir was just created
				if not force and not created[dir or ""]
					var f = io.open(dest, 'r')
					if f
						skips[dest] = 1
						f.close(@)

				if not skips[dest]
					-- create directory if needed
					if dir and not created[dir] and not existed[dir]
						if term.exist_dir(dir)
							existed[dir] = true
						else
							var x, err = term.mkdir(dir)
							if not x
								error(err)
							created[dir] = true

					var f, err = io.open(dest, 'wb')
					if not f
						error(err)

					var srcname = string.gsub(file.path, "(.*[/\\])(.*)", "%2")
					f.write(@, "--\n-- Generated from " .. srcname .. "\n--")
					f.write(@, file.code)
					f.close(@)
			else
				skips[dest] = -1

		-- list files not generated
		var fails, f = {}, 1
		for k, v in pairs(skips)
			if v == 1
				fails[f] = k .. " already exists. Use -f to overwrite"
			else
				fails[f] = "Fail to generate " .. k
			f = f + 1
		print(color.red .. table.concat(fails, "\n") .. color.reset)

else
	-- https://stackoverflow.com/questions/20410082/why-does-the-lua-repl-require-you-to-prep-an-equal-sign-in-order-to-get-a-val
	var print_results = \... ->
		-- This function takes care of nils at the  of results and such
		if select('#', ...) > 1
			print(select(2, ...))


	print("Luaty  \n-- empty line to transpile --")
	var list = {}
	do
		if #list > 0
			io.stdout.write(@, '>>')
		else
			io.stdout.write(@, '> ')
		
		io.stdout.flush(@)
		var s = io.stdin.read(@)
		if s == 'exit' or s == 'quit'
			break
		else if #s == 0
			var str = table.concat(list, "\n")
			list = {}
			var _, code, warns = compile.string(str)
			if warns
				print(warns)
			
			if code
				print(color.yellow .. code .. color.reset)
				var fn, err = loadstring(code)
				if err -- Maybe it's an expression
					-- This is a bad hack, but it might work
					fn = load('return (' .. fn .. ')', 'stdin')
				

				if fn
					io.stdout.write(@, '=>')
					print_results(pcall(fn))
				else
					print(err)

		else
			list[#list + 1] = s
		
	until false