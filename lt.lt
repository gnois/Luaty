var term = require('term')
var compiler = require('lt.compile')
var color = term.color
var write = term.write

var usage = \err ->
	var spec = ``
Usage: 
  luajit lt.lua [-c1|-f1|c|f] [-t] [-d xvar] src.lt [dst]
  where:
    -c1       Transpile src.lt into dst/src.lua without running
    -f1       Same as -c1 but overwrites destination file
    -c        Transpile src.lt and its dependencies into dst/src.lua, dst/*.lua ... without running
    -f        Same as -c but overwrites destination files
    -t        Enable type checking
    -d xvar   Declares `xvar` to silent undeclared identifier warning
  
  dst specifies an output directory and defaults to ./
  If specified, it must not end with .lt

  Running without parameters enters Read-Generate-Eval-Print loop
``
	err = err or ''
	err = err .. '\n' .. spec
	term.usage(err)


var run = true
var force = false
var already = false
var typecheck = false
var single = false
var paths = {}
var decls = {}

for s, p in term.scan({...})
	if s == 'c' or s == 'c1' or s == 'f' or s == 'f1'
		if already
			usage("Error: use either -c or -f only")
		already = true
		run = false
		if s == 'f' or s == 'f1'
			force = true
		if s == 'c1' or s == 'f1'
			single = true
		if p
			table.insert(paths, p)
	else if s == 'd'
		if p
			decls[p] = true
		else
			usage("Error: -d requires identifier")
	else
		if s == 't'
			typecheck = true
		else if s ~= ""
			usage("Error: unknown switch -" .. s)
		if p
			table.insert(paths, p)


var src, dst
if #paths > 2
	usage("Error: only one file with an optional output directory accepted")
else
	src = paths[1]
	dst = paths[2]
	if src
		-- in case is a Windows drive letter
		if string.sub(src, 2, 2) == ':'
			src = string.sub(src, 3)
	if dst
		-- remove slashes at the end
		dst = string.gsub(dst, term.slash .. "*$", "")
		if string.sub(dst, -string.len(".lt")) == ".lt"
			usage("Error: output directory `" .. dst .. "` cannot end with .lt")


var compile = compiler({declares = decls, typecheck = typecheck, single = single}, color)

if src
	var _, code, warns, imports = compile.file(src)
	if run
		if warns
			write(warns)
			write("\n")
		if code
			var fn = assert(loadstring(code))
			fn()
		else
			write(" Fail to run " .. src)
		write("\n")
	else
		var created = {}  -- folders created
		var existed = {}  -- folders already exist
		var skips = {}  -- files not overwritten or failed to compile
		for __, file in pairs(imports)
			write(file.path .. "\n")
			if file.warns
				write(file.warns)
				write("\n")

			-- construct output file path
			var dest = string.gsub(file.path, "%.lt", ".lua")
			if dst
				dest = dst .. term.slash .. dest
			-- dest is now dir/sub/file.lua
			if file.code
				-- split into dir/sub and file.lua
				var name = dest
				var dir
				string.gsub(dest, "(.*[/\\])(.*)", \d, n -> 
					dir = d
					name = n
				)
				-- no need to test against overwrite if dir was just created
				if not force and not created[dir or ""]
					var f = io.open(dest, 'r')
					if f
						skips[dest] = 1
						f.close(@)

				if not skips[dest]
					-- create directory if needed
					if dir and not created[dir] and not existed[dir]
						if term.exist_dir(dir)
							existed[dir] = true
						else
							var x, err = term.mkdir(dir)
							if not x
								error(err)
							created[dir] = true

					var f, err = io.open(dest, 'wb')
					if not f
						error(err)

					var srcname = string.gsub(file.path, "(.*[/\\])(.*)", "%2")
					f.write(@, "--\n-- Generated from " .. srcname .. "\n--")
					f.write(@, file.code)
					f.close(@)
			else
				skips[dest] = -1

		-- list files not generated
		var fails, f = {}, 1
		for k, v in pairs(skips)
			if v == 1
				fails[f] = k .. " already exists. Use -f to overwrite"
			else
				fails[f] = "Fail to generate " .. k
			f = f + 1
		write(color.red .. table.concat(fails, "\n") .. color.reset)

else -- repl
	-- https://stackoverflow.com/questions/20410082/why-does-the-lua-repl-require-you-to-prep-an-equal-sign-in-order-to-get-a-val
	var show_results = \... ->
		-- This function takes care of nils at the end of results and such
		if select('#', ...) > 1
			write(select(2, ...))

	var flush = -> io.stdout.flush(@)
	var read = -> return io.stdin.read(@)

	write("Luaty  \n-- empty line to transpile --\n")
	var list = {}
	do
		write('> ')
		flush()
		var s = read()
		if s == 'exit' or s == 'quit'
			break
		else if s and #s > 0
			list[#list + 1] = s
		else
			var str = table.concat(list, "\n")
			list = {}
			var _, code, warns = compile.string(str)
			if warns
				write(warns)
			if code
				write(color.cyan .. code .. color.reset)
				var fn, err = loadstring(code)
				if err -- Maybe it's an expression
					-- This is a bad hack, but it might work
					fn = load('return (' .. fn .. ')', 'stdin')

				if fn
					show_results(pcall(fn))
				else
					write(err)
			write("\n")
	until false