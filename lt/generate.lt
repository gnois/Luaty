var Tag = require('lua.tag')
var reserved = require('lua.reserved')
var operator = require('lua.operator')
var chars = require('lua.chars')

var TStmt = Tag.Stmt
var TExpr = Tag.Expr
var Keyword = reserved.Keyword
var format = string.format
var concat = table.concat
var is = chars.is


var generate = \stmts ->
	
	var Stmt = {}
	var Expr = {}

	var proto = nil

	var proto_enter = \indent ->
		var ind = 0
		if indent
			ind = indent
		else if proto
			ind = proto.indent
		proto = { code = {}, indent = ind, parent = proto }

	var proto_leave = ->
		proto = proto.parent

	var indent_more = ->
		proto.indent = proto.indent + 1

	var indent_less = ->
		proto.indent = proto.indent - 1


	var proto_inline = ->
		-- remove leading whitespaces from first line
		if #proto.code > 0
			proto.code[1] = string.gsub(proto.code[1], "^%s*", "")
		return concat(proto.code, "\n")

	var emit = \node ->
		var rule = Stmt[node.tag]
		if rule
			return rule(node)
		error("cannot find a statement rule for " .. (node.tag or "nil"))

	var list_emit = \node_list ->
		for i = 1, #node_list
			emit(node_list[i])


	var expr_emit = \node ->
		var rule = Expr[node.tag]
		if rule
			return rule(node)
		error("cannot find an expression rule for " .. (node.tag or "nil"))

	var to_expr = \node, bracket ->
		var val = expr_emit(node)
		if bracket
			return "(" .. val .. ")"
		return val

	var expr_list = \exps ->
		var strls = {}
		var last = #exps
		for k = 1, last
			strls[k] = to_expr(exps[k], k == last and exps[k].bracketed)
		return concat(strls, ", ")

	var add_line = \line ->
		var indent = string.rep("    ", proto.indent)
		proto.code[#proto.code + 1] = indent .. line


	var add_section = \header, body, omit_end ->
		add_line(header)
		indent_more()
		list_emit(body)
		indent_less()
		if not omit_end
			add_line("end")


	---------------- Expressions -----
	var is_plain_string = \node ->
		if node.tag == TExpr.String and type(node.value) == "string"
			var str = node.value
			var c = string.sub(str, 1, 1)
			if c == '' or not is.letter(c)
				return false

			for k = 2, #str
				c = string.sub(str, k, k)
				if not is.letter(c) and not is.digit(c)
					return false

			return not Keyword[str]


	var comma_sep_list = \ls, f ->
		var strls = ls
		if f
			strls = {}
			for k = 1, #ls
				strls[k] = f(ls[k]) 
		return concat(strls, ", ")


	var as_parameter = \node ->
		return node.tag == TExpr.Vararg and "..." or node.name

	var priority = \val ->
		return val, operator.ident_priority


	Expr[TExpr.Id] = \node ->
		return priority(node.name)

	Expr[TExpr.Number] = \node ->
		return priority(node.value)

	Expr[TExpr.Bool] = \node ->
		return priority(tostring(node.value))

	Expr[TExpr.Nil] = ->
		return priority("nil")

	Expr[TExpr.Vararg] = ->
		return priority("...")


	var escape = \s ->
		var replace = {
			'"' = `\"`, '\a' = `\a`, '\b' = `\b`, '\f' = `\f`, '\n' = `\n`, '\r' = `\r`, '\t' = `\t`, '\v' = `\v`
		}
		return string.gsub(s, '["\a\b\f\n\r\t\v]', replace)

	Expr[TExpr.String] = \node ->
		var val = node.value
		var text = val
		if node.long
			-- convert `` to [=[       meaning 2 backtick to 1 equal sign
			var n, m = string.find(val, "^`+")
			if n
				var p, q = string.find(val,"`+$")
				assert(q-p == m-n)
				var eq = string.rep('=', m - n)
				var ls = { "[", eq, "[", string.sub(val, m+1, p-1), "]", eq, "]" }
				text = priority(concat(ls))
		else
			text = format('"%s"', escape(val))
		return priority(text)


	Expr[TExpr.Function] = \node ->
		proto_enter()
		var header = format("function(%s)", comma_sep_list(node.params, as_parameter))
		add_section(header, node.body)
		var code = proto_inline()
		proto_leave()
		return code, 0


	Expr[TExpr.Table] = \node ->
		var hash = {}
		var last = #node.keyvals
		for i = 1, last
			var kv = node.keyvals[i]
			var val = expr_emit(kv[1])
			var key = kv[2]
			if key
				if is_plain_string(key)
					hash[i] = format("%s = %s", key.value, val)
				else
					hash[i] = format("[%s] = %s", expr_emit(key), val)
			
			else
				if i == last and kv[1].bracketed
					hash[i] = format("(%s)", val)
				else
					hash[i] = format("%s", val)

		var content = ""
		if #hash > 0
			content = comma_sep_list(hash)
		return priority("{" .. content .. "}")


	var receiver = \target ->
		var obj, prio = expr_emit(target)
		var t = target.tag
		if prio < operator.ident_priority or t == TExpr.String or t == TExpr.Number or t == TExpr.Bool or t == TExpr.Table
			return "(" .. obj .. ")"
		return obj

	Expr[TExpr.Index] = \node ->
		var obj = receiver(node.object)
		var idx = expr_emit(node.index)
		var exp = format("%s[%s]", obj, idx)
		return priority(exp)


	Expr[TExpr.Property] = \node ->
		var obj = receiver(node.object)
		var exp = format("%s.%s", obj, node.property)
		return priority(exp)


	Expr[TExpr.Call] = \node ->
		var fn = receiver(node.func)
		var exp = format("%s(%s)", fn, expr_list(node.arguments))
		return priority(exp)


	Expr[TExpr.Invoke] = \node ->
		var obj = receiver(node.object)
		var exp = format("%s:%s(%s)", obj, node.method, expr_list(node.arguments))
		return priority(exp)


	Expr[TExpr.Unary] = \node ->
		var arg, arg_prio = expr_emit(node.argument)
		var op_prio = operator.unary_priority
		if arg_prio < op_prio arg = format("(%s)", arg) 
		var op = node.operator
		if op == 'not' op = 'not ' 
		return format("%s%s", op, arg), operator.unary_priority


	Expr[TExpr.Binary] = \node ->
		var oper = node.operator
		var lprio = operator.left_priority(oper)
		var rprio = operator.right_priority(oper)
		var a, alprio, arprio = expr_emit(node.left)
		var b, blprio, brprio = expr_emit(node.right)
		if not arprio arprio = alprio 
		if not brprio brprio = blprio 
		var ap = arprio <  lprio and format("(%s)", a) or a
		var bp = blprio <= rprio and format("(%s)", b) or b
		return format("%s %s %s", ap, oper, bp), lprio, rprio


	---------------- Statements -----
	Stmt[TStmt.Expr] = \node ->
		var line = expr_emit(node.expression)
		add_line(line)
		
		
	Stmt[TStmt.Local] = \node ->
		var line
		var names = comma_sep_list(node.names, as_parameter)
		if #node.expressions > 0
			line = format("local %s = %s", names, expr_list(node.expressions))
		else
			line = format("local %s", names)

		add_line(line)


	Stmt[TStmt.Assign] = \node ->
		var line = format("%s = %s", expr_list(node.left), expr_list(node.right))
		add_line(line)


	Stmt[TStmt.Do] = \node ->
		add_section("do", node.body)


	Stmt[TStmt.If] = \node ->
		var ncons = #node.tests
		for i = 1, ncons
			var header_tag = i == 1 and "if" or "elseif"
			var test = expr_emit(node.tests[i])
			var header = format("%s %s then", header_tag, test)
			add_section(header, node.conds[i], true)

		if node.els
			add_section("else", node.els, true)

		add_line("end")


	Stmt[TStmt.Forin] = \node ->
		var vars = comma_sep_list(node.vars, as_parameter)
		var explist = expr_list(node.explist)
		var header = format("for %s in %s do", vars, explist)
		add_section(header, node.body)


	Stmt[TStmt.Fornum] = \node ->
		var istart = expr_emit(node.first)
		var iend = expr_emit(node.last)
		var header
		if node.step
			if not (node.step.tag == TExpr.Number and node.step.value == 1)
				var step = expr_emit(node.step)
				header = format("for %s = %s, %s, %s do", node.var.name, istart, iend, step)
		
		if not header
			header = format("for %s = %s, %s do", node.var.name, istart, iend)

		add_section(header, node.body)


	Stmt[TStmt.While] = \node ->
		var test = expr_emit(node.test)
		var header = format("while %s do", test)
		add_section(header, node.body)


	Stmt[TStmt.Repeat] = \node ->
		add_section("repeat", node.body, true)
		var test = expr_emit(node.test)
		var until_line = format("until %s", test)
		add_line(until_line)


	Stmt[TStmt.Return] = \node ->
		var line = format("return %s", expr_list(node.arguments))
		add_line(line)


	Stmt[TStmt.Break] = ->
		add_line("break")


	Stmt[TStmt.Goto] = \node ->
		add_line("goto " .. node.label)
	
		
	Stmt[TStmt.Label] = \node ->
		add_line("::" .. node.name .. "::")



	proto_enter()
	list_emit(stmts)
	var code = proto_inline()
	proto_leave()
	return code


return generate
