var Tag = require('lua.tag')

var TStmt = Tag.Stmt
var TExpr = Tag.Expr
var TType = Tag.Type

var make = \tag, node, ls ->
	assert('table' == type(node))
	assert('number' == type(ls.line))
	assert('number' == type(ls.col))
	node.tag = tag
	node.line = ls.line
	node.col = ls.col
	return node

var Statement = {
	expression = \expr, ls ->
		return make(TStmt.Expr, {expr = expr}, ls)
	
	, assign = \lhs, rhs, ls ->
		return make(TStmt.Assign, {lefts = lhs, rights = rhs}, ls)

	, local = \vars, types, exprs, ls ->
		return make(TStmt.Local, {vars = vars, types = types, exprs = exprs}, ls)

	, do = \body, ls ->
		return make(TStmt.Do, {body = body}, ls)

	, if = \tests, thenss, elses, ls ->
		return make(TStmt.If, {tests = tests, thenss = thenss, elses = elses}, ls)

	, forin = \vars, types, exprs, body, ls ->
		return make(TStmt.Forin, {vars = vars, types = types, exprs = exprs, body = body}, ls)

	, fornum = \var, first, last, step, body, ls ->
		return make(TStmt.Fornum, {var = var, first = first, last = last, step = step, body = body}, ls)

	, while = \test, body, ls ->
		return make(TStmt.While, {test = test, body = body}, ls)

	, repeat = \test, body, ls ->
		return make(TStmt.Repeat, {test = test, body = body}, ls)

	, return = \exprs, ls ->
		return make(TStmt.Return, {exprs = exprs}, ls)

	, break = \ls ->
		return make(TStmt.Break, {}, ls)

	, goto = \name, ls ->
		return make(TStmt.Goto, {name = name}, ls)

	, label = \name, ls ->
		return make(TStmt.Label, {name = name}, ls)
}

var Expression = {
	nil = \ls ->
		return make(TExpr.Nil, {}, ls)

	, vararg = \ls ->
		return make(TExpr.Vararg, {}, ls)

	, id = \name, ls ->
		return make(TExpr.Id, {name = name}, ls)

	, bool = \val, ls ->
		return make(TExpr.Bool, {value = val}, ls)

	, number = \val, ls ->
		return make(TExpr.Number, {value = val}, ls)

	, string = \val, long, ls ->
		return make(TExpr.String, {value = val, long = long}, ls)

	, function = \params, types, retypes, body, ls ->
		return make(TExpr.Function, {params = params, types = types, retypes = retypes, body = body}, ls)

	, table = \valkeys, ls ->
		return make(TExpr.Table, {valkeys = valkeys}, ls)

	, index = \obj, index, ls ->
		return make(TExpr.Index, {obj = obj, idx = index}, ls)

	, property = \obj, prop, ls ->
		return make(TExpr.Property, {obj = obj, prop = prop}, ls)

	, invoke = \obj, prop, args, ls ->
		return make(TExpr.Invoke, {obj = obj, prop = prop, args = args}, ls)

	, call = \func, args, ls ->
		return make(TExpr.Call, {func = func, args = args}, ls)

	, union = \variants, test, arg, ls ->
		return make(TExpr.Union, {variants = variants, test = test, arg = arg}, ls)

	, unary = \op, right, ls ->
		return make(TExpr.Unary, {op = op, right = right}, ls)

	, binary = \op, left, right, ls ->
		return make(TExpr.Binary, {op = op, left = left, right = right}, ls)
}



--``
1,2,3, .. typevar
# number
$ string
! bool
. vararg
- optional/nillable. If used in func return [:-] means void
* any, but not pure nil
[:] type tuple to type tuple - function
{:} type to type - table
{} array
~1,2,3... typeof
--``
var id = 0

var Type = {
	new = \ls ->
		id = id + 1
		return make(TType.New, {id = id}, ls)

	, any = \ls ->
		return make(TType.Any, {}, ls)

	, nil = \ls ->
		return make(TType.Nil, {}, ls)

	, num = \ls ->
		return make(TType.Val, {type = "num"}, ls)

	, str = \ls ->
		return make(TType.Val, {type = "str"}, ls)

	, bool = \ls ->
		return make(TType.Val, {type = "bool"}, ls)

	, tuple = \types, ls ->
		return make(TType.Tuple, {types = types}, ls)

	-- params and returns are tuples
	, func = \params, returns, ls ->
		return make(TType.Ref, {params = params, returns = returns}, ls)

	, tbl = \tytys, ls ->
		-- Lua table key can be any type
		-- If it's string, we'll use back the string literal, else it'll be a Type object
		return make(TType.Ref, {tytys = tytys}, ls)

	, or = \left, right, ls ->
		return make(TType.Or, {left = left, right = right}, ls)

	, and = \left, right, ls ->
		return make(TType.And, {left = left, right = right}, ls)

	, index = \obj, prop, ls ->
		return make(TType.Index, {obj = obj, prop = prop}, ls)

	-- only identifier accepted, not ls
	, typeof = \name, ls ->
		return make(TType.Typeof, {name = name}, ls)
}

var bracket = \node ->
	assert(TExpr[node.tag] or TType[node.tag])  -- must be expression or type node
	node.bracketed = true
	return node

-- return false if already vararg'ed
var varargs = \t ->
	assert(TType[t.tag])  -- must be type node
	if t.varargs
		return false
	t.varargs = true
	return true

-- return false if already nil'ed
var nils = \t ->
	assert(TType[t.tag])  -- must be type node
	if t.nil
		return false
	t.nil = true
	return true


var Str = {}
var tostr
var tolst = \ls ->
	var out = {}
	for i, p in ipairs(ls)
		out[i] = tostr(p)
	return table.concat(out, ',')

tostr = \t ->
	assert(TType[t.tag])
	var rule = Str[t.tag]
	return rule(t)
	
Str[TType.New] = \t ->
	return "T" .. t.id

Str[TType.Any] = \t ->
	return "any"

Str[TType.Nil] = \t ->
	return "nil"

Str[TType.Val] = \t ->
	return t.type

Str[TType.Ref] = \t ->
	if t.params
		var out = {'[', tolst(t.params), ':', tolst(t.returns), ']'}
		return table.concat(out)
	
	if t.tytys
		var out, o = {}, 1
		var val
		for _, ty in ipairs(t.tytys)
			var vty = ty[1]
			var kty = ty[2]
			if kty
				if "string" == type(kty)
					out[o] = kty .. ': ' .. tostr(vty)
				else
					out[o] = tostr(kty) .. ': ' .. tostr(vty)
				o = o + 1
			else
				val = tostr(vty)
		
		var ls = table.concat(out, ', ')
		if val
			ls = val .. ', ' .. ls
		return '{' .. ls .. '}'



-- check if ast are the same
var same
same = \a, b ->
	if a and b and a.tag == b.tag
		-- http://stackoverflow.com/questions/27674367/lua-check-if-a-table-can-be-looped-through-via-ipairs-ipairs-starting-at-0
		if #a ~= #b
			return false

		-- check array part
		var last = 1
		for i, v in ipairs(a)
			last = i
			if 'table' == type(v)
				if not same(v, b[i])
					return false
			else if b[i] ~= v
				return false

		-- check hashmap part
		for k, v in pairs(a)
			if 'number' ~= type(k) or k < 1 or k > last or math.floor(k) ~= k
				-- ignore line,col
				if k ~= 'line' and k ~= 'col'
					if 'table' == type(v)
						if not same(v, b[k])
							return false
					else if b[k] ~= v
						return false

		-- b may have more keys than a
		for k, v in pairs(b)
			if 'number' ~= type(k) or k < 1 or k > last or math.floor(k) ~= k
				-- ignore line,col
				if k ~= 'line' and k ~= 'col'
					if 'table' == type(v)
						if not same(v, a[k])
							return false
					else if a[k] ~= v
						return false

		return true
	return false



return {
	Stmt = Statement
	, Expr = Expression
	, Type = Type
	, bracket = bracket
	, varargs = varargs
	, nils = nils
	, same = same
	, tostr = tostr
}
