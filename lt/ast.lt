var Tag = require('lua.tag')

var TStmt = Tag.Stmt
var TExpr = Tag.Expr
var TType = Tag.Type

var make = \tag, node, ls ->
	assert('table' == type(node))
	assert('number' == type(ls.line))
	assert('number' == type(ls.col))
	node.tag = tag
	node.line = ls.line
	node.col = ls.col
	return node


var Statement = {

	expression = \expr, ls ->
		return make(TStmt.Expr, {expr = expr}, ls)
	
	, assign = \lhs, rhs, ls ->
		return make(TStmt.Assign, {lefts = lhs, rights = rhs}, ls)

	, local = \vars, types, exprs, ls ->
		return make(TStmt.Local, {vars = vars, types = types, exprs = exprs}, ls)

	, do = \body, ls ->
		return make(TStmt.Do, {body = body}, ls)

	, if = \tests, thenss, elses, ls ->
		return make(TStmt.If, {tests = tests, thenss = thenss, elses = elses}, ls)

	, forin = \vars, types, exprs, body, ls ->
		return make(TStmt.Forin, {vars = vars, types = types, exprs = exprs, body = body}, ls)

	, fornum = \var, first, last, step, body, ls ->
		return make(TStmt.Fornum, {var = var, first = first, last = last, step = step, body = body}, ls)

	, while = \test, body, ls ->
		return make(TStmt.While, {test = test, body = body}, ls)

	, repeat = \test, body, ls ->
		return make(TStmt.Repeat, {test = test, body = body}, ls)

	, return = \exprs, ls ->
		return make(TStmt.Return, {exprs = exprs}, ls)

	, break = \ls ->
		return make(TStmt.Break, {}, ls)

	, goto = \name, ls ->
		return make(TStmt.Goto, {name = name}, ls)

	, label = \name, ls ->
		return make(TStmt.Label, {name = name}, ls)

}

var Expression = {

	nil = \ls ->
		return make(TExpr.Nil, {}, ls)

	, vararg = \ls ->
		return make(TExpr.Vararg, {}, ls)

	, id = \name, ls ->
		return make(TExpr.Id, {name = name}, ls)

	, bool = \val, ls ->
		return make(TExpr.Bool, {value = val}, ls)

	, number = \val, ls ->
		return make(TExpr.Number, {value = val}, ls)

	, string = \val, long, ls ->
		return make(TExpr.String, {value = val, long = long}, ls)

	, function = \params, types, retypes, body, ls ->
		return make(TExpr.Function, {params = params, types = types, retypes = retypes, body = body}, ls)

	, table = \valkeys, ls ->
		return make(TExpr.Table, {valkeys = valkeys}, ls)

	, index = \obj, index, ls ->
		return make(TExpr.Index, {obj = obj, idx = index}, ls)

	, property = \obj, prop, ls ->
		return make(TExpr.Property, {obj = obj, prop = prop}, ls)

	, invoke = \obj, prop, args, ls ->
		return make(TExpr.Invoke, {obj = obj, prop = prop, args = args}, ls)

	, call = \func, args, ls ->
		return make(TExpr.Call, {func = func, args = args}, ls)

	, unary = \op, left, ls ->
		return make(TExpr.Unary, {op = op, left = left}, ls)

	, binary = \op, left, right, ls ->
		return make(TExpr.Binary, {op = op, left = left, right = right}, ls)

}


var build = \ty, obj, node ->
	obj.type = ty
	obj.node = node
	return obj


var Type = {
	-- atomic
	any = \node ->
		return build(TType.Any, {}, node)

	, num = \node ->
		return build(TType.Num, {}, node)

	, str = \node ->
		return build(TType.Str, {}, node)

	, bool = \node ->
		return build(TType.Bool, {}, node)

	, func = \params, returns, node ->
		return build(TType.Func, {params = params, returns = returns}, node)

	, tbl = \valkeys, node ->
		return build(TType.Tbl, {valkeys = valkeys}, node)

	-- compound
	, or = \left, right, node ->
		return build(TType.Or, {left = left, right = right}, node)

	, and = \left, right, node ->
		return build(TType.And, {left = left, right = right}, node)

	, index = \obj, prop, node ->
		return build(TType.Index, {obj = obj, prop = prop}, node)

	, custom = \name, node ->
		return build(TType.Custom, {name = name}, node)
}


var bracket = \node ->
	assert(TExpr[node.tag] or TType[node.type])  -- must be expression or type node
	node.bracketed = true
	return node

var nils = \node ->
	assert(TType[node.type])  -- must be type node
	node.nil = true
	return node
	
var varargs = \node ->
	assert(TType[node.type])  -- must be type node
	node.varargs = true
	return node

var nillable = \node ->
	assert(TType[node.type])  -- must be type node
	return node.nil

	
return {
	Stmt = Statement
	, Expr = Expression
	, Type = Type
	, bracket = bracket
	, nils = nils
	, varargs = varargs
	, nillable = nillable
}