var Tag = require('lua.tag')

var TStmt = Tag.Stmt
var TExpr = Tag.Expr
var TType = Tag.Type

var make = \tag, node, ls ->
	assert('table' == type(node))
	assert('number' == type(ls.line))
	assert('number' == type(ls.col))
	node.tag = tag
	node.line = ls.line
	node.col = ls.col
	return node

var Statement = {
	expression = \expr, ls ->
		return make(TStmt.Expr, {expr = expr}, ls)
	
	, assign = \lhs, rhs, ls ->
		return make(TStmt.Assign, {lefts = lhs, rights = rhs}, ls)

	, local = \vars, types, exprs, ls ->
		return make(TStmt.Local, {vars = vars, types = types, exprs = exprs}, ls)

	, do = \body, ls ->
		return make(TStmt.Do, {body = body}, ls)

	, if = \tests, thenss, elses, ls ->
		return make(TStmt.If, {tests = tests, thenss = thenss, elses = elses}, ls)

	, forin = \vars, types, exprs, body, ls ->
		return make(TStmt.Forin, {vars = vars, types = types, exprs = exprs, body = body}, ls)

	, fornum = \var, first, last, step, body, ls ->
		return make(TStmt.Fornum, {var = var, first = first, last = last, step = step, body = body}, ls)

	, while = \test, body, ls ->
		return make(TStmt.While, {test = test, body = body}, ls)

	, repeat = \test, body, ls ->
		return make(TStmt.Repeat, {test = test, body = body}, ls)

	, return = \exprs, ls ->
		return make(TStmt.Return, {exprs = exprs}, ls)

	, break = \ls ->
		return make(TStmt.Break, {}, ls)

	, goto = \name, ls ->
		return make(TStmt.Goto, {name = name}, ls)

	, label = \name, ls ->
		return make(TStmt.Label, {name = name}, ls)
}

var Expression = {
	nil = \ls ->
		return make(TExpr.Nil, {}, ls)

	, vararg = \ls ->
		return make(TExpr.Vararg, {}, ls)

	, id = \name, ls ->
		return make(TExpr.Id, {name = name}, ls)

	, bool = \val, ls ->
		return make(TExpr.Bool, {value = val}, ls)

	, number = \val, ls ->
		return make(TExpr.Number, {value = val}, ls)

	, string = \val, long, ls ->
		return make(TExpr.String, {value = val, long = long}, ls)

	, function = \params, types, retypes, body, ls ->
		return make(TExpr.Function, {params = params, types = types, retypes = retypes, body = body}, ls)

	, table = \valkeys, ls ->
		return make(TExpr.Table, {valkeys = valkeys}, ls)

	, index = \obj, index, ls ->
		return make(TExpr.Index, {obj = obj, idx = index}, ls)

	, property = \obj, prop, ls ->
		return make(TExpr.Property, {obj = obj, prop = prop}, ls)

	, invoke = \obj, prop, args, ls ->
		return make(TExpr.Invoke, {obj = obj, prop = prop, args = args}, ls)

	, call = \func, args, ls ->
		return make(TExpr.Call, {func = func, args = args}, ls)

	, union = \variants, test, arg, ls ->
		return make(TExpr.Union, {variants = variants, test = test, arg = arg}, ls)

	, unary = \op, right, ls ->
		return make(TExpr.Unary, {op = op, right = right}, ls)

	, binary = \op, left, right, ls ->
		return make(TExpr.Binary, {op = op, left = left, right = right}, ls)
}



var create = \tag, node, expr ->
	assert('table' == type(node))
	assert('table' == type(expr))
	assert(TExpr[expr.tag])  -- must be expression node
	node.tag = tag
	node.expr = expr
	return node

var id = 0

var Type = {
	new = \expr ->
		id = id + 1
		return create(TType.Var, {name = 'T' .. id}, expr)

	, any = \expr ->
		return create(TType.Any, {}, expr)

	, nil = \expr ->
		return create(TType.Nil, {}, expr)

	, num = \expr ->
		return create(TType.Num, {}, expr)

	, str = \expr ->
		return create(TType.Str, {}, expr)

	, bool = \expr ->
		return create(TType.Bool, {}, expr)

	, func = \params, returns, expr ->
		return create(TType.Func, {params = params, returns = returns}, expr)

	, tbl = \typekeys, expr ->
		return create(TType.Tbl, {typekeys = typekeys}, expr)

	, or = \left, right, expr ->
		return create(TType.Or, {left = left, right = right}, expr)

	, and = \left, right, expr ->
		return create(TType.And, {left = left, right = right}, expr)

	, index = \obj, prop, expr ->
		return create(TType.Index, {obj = obj, prop = prop}, expr)

	-- only identifier accepted, not expr
	, typeof = \name, expr ->
		return create(TType.Typeof, {name = name}, expr)
}

var bracket = \node ->
	assert(TExpr[node.tag] or TType[node.tag])  -- must be expression or type node
	node.bracketed = true
	return node

-- return false if already vararg'ed
var varargs = \node ->
	assert(TType[node.tag])  -- must be type node
	if node.varargs
		return false
	node.varargs = true
	return true

-- return false if already nil'ed
var nils = \node ->
	assert(TType[node.tag])  -- must be type node
	if node.nil
		return false
	node.nil = true
	return true


var tostr = \node ->
	assert(TType[node.tag])
	
	

-- check if ast are the same
var same
same = \a, b ->
	if a and b and a.tag == b.tag
		-- http://stackoverflow.com/questions/27674367/lua-check-if-a-table-can-be-looped-through-via-ipairs-ipairs-starting-at-0
		if #a ~= #b
			return false

		-- check array part
		var last = 1
		for i, v in ipairs(a)
			last = i
			if 'table' == type(v)
				if not same(v, b[i])
					return false
			else if b[i] ~= v
				return false

		-- check hashmap part
		for k, v in pairs(a)
			if 'number' ~= type(k) or k < 1 or k > last or math.floor(k) ~= k
				-- ignore line,col
				if k ~= 'line' and k ~= 'col'
					if 'table' == type(v)
						if not same(v, b[k])
							return false
					else if b[k] ~= v
						return false

		-- b may have more keys than a
		for k, v in pairs(b)
			if 'number' ~= type(k) or k < 1 or k > last or math.floor(k) ~= k
				-- ignore line,col
				if k ~= 'line' and k ~= 'col'
					if 'table' == type(v)
						if not same(v, a[k])
							return false
					else if a[k] ~= v
						return false

		return true
	return false



return {
	Stmt = Statement
	, Expr = Expression
	, Type = Type
	, bracket = bracket
	, varargs = varargs
	, nils = nils
	, same = same
}
