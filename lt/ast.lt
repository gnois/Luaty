var build = \kind, node ->
	node.kind = kind
	return node

var ident = \name, line ->
	return build("Identifier", { name = name, line = line })


var AST = {}

AST.chunk = \ast, body, chunkname, firstline, lastline ->
	return build("Chunk", { body = body, chunkname = chunkname, firstline = firstline, lastline = lastline })

AST.expr_function = \ast, args, body, proto ->
	return build("FunctionExpression", { body = body, params = args, vararg = proto.varargs, firstline = proto.firstline, lastline = proto.lastline })


AST.local_decl = \ast, vlist, exps, line ->
	var ids = {}
	for k = 1, #vlist
		ids[k] = ast.var_declare(@, vlist[k])
	
	return build("LocalDeclaration", { names = ids, expressions = exps, line = line })


AST.assignment_expr = \ast, vars, exps, line ->
	return build("AssignmentExpression", { left = vars, right = exps, line = line })


AST.expr_index = \ast, v, index, line ->
	return build("MemberExpression", { object = v, property = index, computed = true, line = line })


AST.expr_property = \ast, v, prop, line ->
	var index = ident(prop, line)
	return build("MemberExpression", { object = v, property = index, computed = false, line = line })


AST.literal = \ast, val, line ->
	return build("Literal", { value = val, line = line })


AST.numberliteral = \ast, val ->
	return build("NumberLiteral", { value = val, line = line })


AST.longstrliteral = \ast, txt ->
	return build("LongStringLiteral", { text = txt, line = line })


AST.expr_vararg = \ast ->
	return build("Vararg", {})


AST.expr_brackets = \ast, expr ->
	expr.bracketed = true
	return expr

--[[
AST.set_expr_last = \ast, expr ->
	if expr.bracketed
		var k = expr.kind
		if k == "CallExpression" or k == "SendExpression" or k == "Vararg"
			expr.bracketed = nil
		return build("ExpressionValue", { value = expr })
	else
		return expr
]]

AST.expr_table = \ast, keyvals, line ->
	return build("Table", { keyvals = keyvals, line = line })


AST.expr_unop = \ast, op, v, line ->
	return build("UnaryExpression", { operator = op, argument = v, line = line })


var concat_append = \ts, node ->
	var n = #ts
	if node.kind == "ConcatenateExpression"
		for k = 1, #node.terms
			ts[n + k] = node.terms[k]
	else
		ts[n + 1] = node
	


AST.expr_binop = \ast, op, expa, expb, line ->
	var binop_body = (op ~= '..' and { operator = op, left = expa, right = expb, line = line })
	if binop_body
		if op == 'and' or op == 'or'
			return build("LogicalExpression", binop_body)
		else
			return build("BinaryExpression", binop_body)
	else
		var terms = {}
		concat_append(terms, expa)
		concat_append(terms, expb)
		return build("ConcatenateExpression", { terms = terms, line = expa.line })
	


AST.identifier = \ast, name, line ->
	return ident(name, line)


AST.expr_method_call = \ast, v, key, args, line ->
	var m = ident(key, line)
	return build("SendExpression", { receiver = v, method = m, arguments = args, line = line })

AST.expr_function_call = \ast, v, args, line ->
	return build("CallExpression", { callee = v, arguments = args, line = line })


AST.return_stmt = \ast, exps, line ->
	return build("ReturnStatement", { arguments = exps, line = line })


AST.break_stmt = \ast, line ->
	return build("BreakStatement", { line = line })


AST.label_stmt = \ast, name, line ->
	return build("LabelStatement", { label = name, line = line })


AST.new_statement_expr = \ast, expr, line ->
	return build("ExpressionStatement", { expression = expr, line = line })


AST.if_stmt = \ast, tests, cons, else_branch, line ->
	return build("IfStatement", { tests = tests, cons = cons, alternate = else_branch, line = line })


AST.do_stmt = \ast, body, line, lastline ->
	return build("DoStatement", { body = body, line = line, lastline = lastline})


AST.while_stmt = \ast, test, body, line, lastline ->
	return build("WhileStatement", { test = test, body = body, line = line, lastline = lastline })


AST.repeat_stmt = \ast, test, body, line, lastline ->
	return build("RepeatStatement", { test = test, body = body, line = line, lastline = lastline })


AST.for_stmt = \ast, variable, init, last, step, body, line, lastline ->
	var for_init = build("ForInit", { id = variable, value = init, line = line })
	return build("ForStatement", { init = for_init, last = last, step = step, body = body, line = line, lastline = lastline })


AST.for_iter_stmt = \ast, vars, exps, body, line, lastline ->
	var names = build("ForNames", { names = vars, line = line })
	return build("ForInStatement", { namelist = names, explist = exps, body = body, line = line, lastline = lastline })


AST.goto_stmt = \ast, name, line ->
	return build("GotoStatement", { label = name, line = line })


var new_scope = \parent_scope ->
	return {
		vars = {}
		, parent = parent_scope
	}


AST.var_declare = \ast, name, line ->
	var id = ident(name, line)
	ast.current.vars[name] = true
	return id


AST.fscope_begin = \ast ->
	ast.current = new_scope(ast.current)


AST.fscope_end = \ast ->
	ast.current = ast.current.parent



---- lint checks --------------------------------------
AST.in_scope = \ast, v ->
	if v.name
		var scope = ast.current
		while not scope.vars[v.name]
			scope = scope.parent
			if not scope
				return false
		return true
	return false


AST.overwritten = \ast, vars ->
	var n = #vars
	for i = 1, n
		var v = vars[i]
		for j = i+1, n
			if vars[j] == v
				return v

		var scope = ast.current
		-- shadowing var at parent scope is normal, but we want to be careful
		do
			if scope.vars[v]
				return v
			scope = scope.parent
		until not scope


var same
same = \a, b ->
	if a and b and a.kind == b.kind
		-- http://stackoverflow.com/questions/27674367/lua-check-if-a-table-can-be-looped-through-via-ipairs-ipairs-starting-at-0
		var last = 1
		if #a ~= #b
			return false
	
		for i, v in ipairs(a)
			last = i
			if "table" == type(v)
				if not same(v, b[i])
					return false
			
			else if b[i] ~= v
				return false
	
		for k, v in pairs(a)
			if "number" ~= type(k) or k < 1 or k > last or math.floor(k) ~= k
				if "table" == type(v)
					if not same(v, b[k])
						return false
				
				else if b[k] ~= v
					return false
	
		-- b may have more keys than a
		for k, v in pairs(b)
			if "number" ~= type(k) or k < 1 or k > last or math.floor(k) ~= k
				if "table" == type(v)
					if not same(v, a[k])
						return false
				
				else if a[k] ~= v
					return false
	
		return true
	return false


AST.same = same


return {
	New = ->
		return setmetatable({}, { __index = AST })
}

