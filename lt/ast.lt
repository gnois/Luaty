var Tag = require('lua.tag')

var TStmt = Tag.Stmt
var TExpr = Tag.Expr
var TType = Tag.Type

var make = \tag, node, ls ->
	assert('table' == type(node))
	assert('number' == type(ls.line))
	assert('number' == type(ls.col))
	node.tag = tag
	node.line = ls.line
	node.col = ls.col
	return node


var Statement = {

	expression = \expr, ls ->
		return make(TStmt.Expr, {expr = expr}, ls)
	
	, assign = \lhs, rhs, ls ->
		return make(TStmt.Assign, {lefts = lhs, rights = rhs}, ls)

	, local = \vars, exprs, ls ->
		return make(TStmt.Local, {vars = vars, exprs = exprs}, ls)

	, do = \body, ls ->
		return make(TStmt.Do, {body = body}, ls)

	, if = \tests, thenss, elses, ls ->
		return make(TStmt.If, {tests = tests, thenss = thenss, elses = elses}, ls)

	, forin = \vars, exprs, body, ls ->
		return make(TStmt.Forin, {vars = vars, exprs = exprs, body = body}, ls)

	, fornum = \var, first, last, step, body, ls ->
		return make(TStmt.Fornum, {var = var, first = first, last = last, step = step, body = body}, ls)

	, while = \test, body, ls ->
		return make(TStmt.While, {test = test, body = body}, ls)

	, repeat = \test, body, ls ->
		return make(TStmt.Repeat, {test = test, body = body}, ls)

	, return = \exprs, ls ->
		return make(TStmt.Return, {exprs = exprs}, ls)

	, break = \ls ->
		return make(TStmt.Break, {}, ls)

	, goto = \name, ls ->
		return make(TStmt.Goto, {name = name}, ls)

	, label = \name, ls ->
		return make(TStmt.Label, {name = name}, ls)

}

var Expression = {

	nil = \ls ->
		return make(TExpr.Nil, {}, ls)

	, vararg = \ls ->
		return make(TExpr.Vararg, {}, ls)

	, id = \name, ls ->
		return make(TExpr.Id, {name = name}, ls)

	, bool = \val, ls ->
		return make(TExpr.Bool, {value = val}, ls)

	, number = \val, ls ->
		return make(TExpr.Number, {value = val}, ls)

	, string = \val, long, ls ->
		return make(TExpr.String, {value = val, long = long}, ls)

	, function = \params, body, vararg, ls ->
		return make(TExpr.Function, {body = body, params = params, vararg = vararg}, ls)

	, table = \valkeys, ls ->
		return make(TExpr.Table, {valkeys = valkeys}, ls)

	, index = \obj, index, ls ->
		return make(TExpr.Index, {obj = obj, idx = index}, ls)

	, property = \obj, prop, ls ->
		return make(TExpr.Property, {obj = obj, prop = prop}, ls)

	, invoke = \obj, prop, args, ls ->
		return make(TExpr.Invoke, {obj = obj, prop = prop, args = args}, ls)

	, call = \func, args, ls ->
		return make(TExpr.Call, {func = func, args = args}, ls)

	, unary = \op, left, ls ->
		return make(TExpr.Unary, {op = op, left = left}, ls)

	, binary = \op, left, right, ls ->
		return make(TExpr.Binary, {op = op, left = left, right = right}, ls)

}


var Type = {
	-- atomic
	any = ->
		return make(TType.Any, {})

	, num = ->
		return make(TType.Num, {})

	, str = ->
		return make(TType.Str, {})

	, bool = ->
		return make(TType.Bool, {})

	, func = \params, returns ->
		return make(TType.Func, {params = params, returns = returns})

	, tbl = \valkeys ->
		return make(TType.Tbl, {valkeys = valkeys})

	-- compound
	, or = \left, right ->
		return make(TType.Or, {left = left, right = right})

	, and = \left, right ->
		return make(TType.And, {left = left, right = right})

	, not = \ty ->
		return make(TType.Not, {ty})

	, index = \obj, prop ->
		return make(TType.Index, {obj = obj, prop = prop})

	, keyed = \name ->
		return make(TType.Keyed, {name = name})

	, custom = \name ->
		return make(TType.Custom, {name = name})
}


var bracket = \node ->
	--assert(TExpr[node.tag] or TType[node.tag])  -- must be expression or type node
	node.bracketed = true
	return node

var nils = \node ->
	--assert(TType[node.tag])  -- must be type node
	node.nil = true
	return node
	
var varargs = \node ->
	--assert(TType[node.tag])  -- must be type node
	node.varargs = true
	return node
	
var nillable = \node ->
	--assert(TType[node.tag])  -- must be type node
	return node.nil

	
return {
	Stmt = Statement
	, Expr = Expression
	, Type = Type
	, bracket = bracket
	, nils = nils
	, varargs = varargs
	, nillable = nillable
}