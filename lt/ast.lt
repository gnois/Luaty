var Tag = require('lua.tag')

var TStmt = Tag.Stmt
var TExpr = Tag.Expr

var make = \tag, node, line ->
	assert('table' == type(node))
	node.tag = tag
	node.line = line
	return node


var Stmt = {

	expression = \expr, line ->
		return make(TStmt.Expr, {expression = expr}, line)
	
	, declare = \lhs, rhs, line ->
		return make(TStmt.Local, {names = lhs, expressions = rhs}, line)

	, assign = \lhs, rhs, line ->
		return make(TStmt.Assign, {left = lhs, right = rhs}, line)

	, do = \body, line ->
		return make(TStmt.Do, {body = body}, line)

	, if = \tests, conds, els, line ->
		return make(TStmt.If, {tests = tests, conds = conds, els = els}, line)

	, forin = \vars, exprs, body, line ->
		return make(TStmt.Forin, {vars = vars, explist = exprs, body = body}, line)

	, fornum = \var, first, last, step, body, line ->
		return make(TStmt.Fornum, {var = var, first = first, last = last, step = step, body = body}, line)

	, while = \test, body, line ->
		return make(TStmt.While, {test = test, body = body}, line)

	, repeat = \test, body, line ->
		return make(TStmt.Repeat, {test = test, body = body}, line)

	, return = \exps, line ->
		return make(TStmt.Return, {arguments = exps}, line)

	, break = \line ->
		return make(TStmt.Break, {}, line)

	, goto = \label, line ->
		return make(TStmt.Goto, {label = label}, line)

	, label = \name, line ->
		return make(TStmt.Label, {name = name}, line)

}

var Expr = {

	null = \line ->
		return make(TExpr.Nil, {}, line)
	
	, vararg = \line ->
		return make(TExpr.Vararg, {}, line)

	, bool = \val, line ->
		return make(TExpr.Bool, {value = val}, line)

	, number = \val, line ->
		return make(TExpr.Number, {value = val}, line)

	, string = \val, long, line ->
		return make(TExpr.String, {value = val, long = long}, line)

	, function = \params, body, vararg, line ->
		return make(TExpr.Function, {body = body, params = params, vararg = vararg}, line)

	, table = \keyvals, line ->
		return make(TExpr.Table, {keyvals = keyvals}, line)

	, index = \obj, index, line ->
		return make(TExpr.Index, {object = obj, index = index}, line)

	, property = \obj, prop, line ->
		return make(TExpr.Property, {object = obj, property = prop}, line)

	, call = \func, args, line ->
		return make(TExpr.Call, {func = func, arguments = args}, line)
	
	, invoke = \obj, method, args, line ->
		return make(TExpr.Invoke, {object = obj, method = method, arguments = args}, line)

	, unary = \op, v, line ->
		return make(TExpr.Unary, {operator = op, argument = v}, line)

	, binary = \op, left, right, line ->
		return make(TExpr.Binary, {operator = op, left = left, right = right}, line)

	, id = \name, line ->
		return make(TExpr.Id, {name = name}, line)

}

var bracket = \node ->
	assert('table' == type(node))
	node.bracketed = true
	return node


var same
same = \a, b ->
	if a and b and a.tag == b.tag
		-- http://stackoverflow.com/questions/27674367/lua-check-if-a-table-can-be-looped-through-via-ipairs-ipairs-starting-at-0
		var last = 1
		if #a ~= #b
			return false
	
		for i, v in ipairs(a)
			last = i
			if 'table' == type(v)
				if not same(v, b[i])
					return false
			else if b[i] ~= v
				return false
	
		for k, v in pairs(a)
			if 'number' ~= type(k) or k < 1 or k > last or math.floor(k) ~= k
				if 'table' == type(v)
					if not same(v, b[k])
						return false
				else if b[k] ~= v
					return false
	
		-- b may have more keys than a
		for k, v in pairs(b)
			if 'number' ~= type(k) or k < 1 or k > last or math.floor(k) ~= k
				if 'table' == type(v)
					if not same(v, a[k])
						return false
				else if a[k] ~= v
					return false
	
		return true
	return false


return {
	Stmt = Stmt
	, Expr = Expr
	, bracket = bracket
	, same = same
}