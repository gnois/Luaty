var Tag = require('lua.tag')

var TStmt = Tag.Stmt
var TExpr = Tag.Expr

var make = \tag, node, ls ->
	assert('table' == type(node))
	assert('number' == type(ls.line))
	assert('number' == type(ls.col))
	node.tag = tag
	node.line = ls.line
	node.col = ls.col
	return node


var Statement = {

	expression = \expr, ls ->
		return make(TStmt.Expr, {expr = expr}, ls)
	
	, assign = \lhs, rhs, ls ->
		return make(TStmt.Assign, {lefts = lhs, rights = rhs}, ls)

	, local = \vars, exprs, ls ->
		return make(TStmt.Local, {vars = vars, exprs = exprs}, ls)

	, do = \body, ls ->
		return make(TStmt.Do, {body = body}, ls)

	, if = \tests, thenss, elses, ls ->
		return make(TStmt.If, {tests = tests, thenss = thenss, elses = elses}, ls)

	, forin = \vars, exprs, body, ls ->
		return make(TStmt.Forin, {vars = vars, exprs = exprs, body = body}, ls)

	, fornum = \var, first, last, step, body, ls ->
		return make(TStmt.Fornum, {var = var, first = first, last = last, step = step, body = body}, ls)

	, while = \test, body, ls ->
		return make(TStmt.While, {test = test, body = body}, ls)

	, repeat = \test, body, ls ->
		return make(TStmt.Repeat, {test = test, body = body}, ls)

	, return = \exprs, ls ->
		return make(TStmt.Return, {exprs = exprs}, ls)

	, break = \ls ->
		return make(TStmt.Break, {}, ls)

	, goto = \name, ls ->
		return make(TStmt.Goto, {name = name}, ls)

	, label = \name, ls ->
		return make(TStmt.Label, {name = name}, ls)

}

var Expression = {

	null = \ls ->
		return make(TExpr.Nil, {}, ls)
	
	, vararg = \ls ->
		return make(TExpr.Vararg, {}, ls)

	, id = \name, ls ->
		return make(TExpr.Id, {name = name}, ls)

	, bool = \val, ls ->
		return make(TExpr.Bool, {value = val}, ls)

	, number = \val, ls ->
		return make(TExpr.Number, {value = val}, ls)

	, string = \val, long, ls ->
		return make(TExpr.String, {value = val, long = long}, ls)

	, function = \params, body, vararg, ls ->
		return make(TExpr.Function, {body = body, params = params, vararg = vararg}, ls)

	, table = \keyvals, ls ->
		return make(TExpr.Table, {keyvals = keyvals}, ls)

	, index = \obj, index, ls ->
		return make(TExpr.Index, {obj = obj, idx = index}, ls)

	, property = \obj, prop, ls ->
		return make(TExpr.Property, {obj = obj, prop = prop}, ls)

	, invoke = \obj, prop, args, ls ->
		return make(TExpr.Invoke, {obj = obj, prop = prop, args = args}, ls)

	, call = \func, args, ls ->
		return make(TExpr.Call, {func = func, args = args}, ls)

	, unary = \op, left, ls ->
		return make(TExpr.Unary, {op = op, left = left}, ls)

	, binary = \op, left, right, ls ->
		return make(TExpr.Binary, {op = op, left = left, right = right}, ls)

}

var bracket = \node ->
	assert('table' == type(node))
	node.bracketed = true
	return node



var same
same = \a, b ->
	if a and b and a.tag == b.tag
		-- http://stackoverflow.com/questions/27674367/lua-check-if-a-table-can-be-looped-through-via-ipairs-ipairs-starting-at-0
		var last = 1
		if #a ~= #b
			return false
	
		for i, v in ipairs(a)
			last = i
			if 'table' == type(v)
				if not same(v, b[i])
					return false
			else if b[i] ~= v
				return false
	
		for k, v in pairs(a)
			if 'number' ~= type(k) or k < 1 or k > last or math.floor(k) ~= k
				if 'table' == type(v)
					if not same(v, b[k])
						return false
				else if b[k] ~= v
					return false
	
		-- b may have more keys than a
		for k, v in pairs(b)
			if 'number' ~= type(k) or k < 1 or k > last or math.floor(k) ~= k
				if 'table' == type(v)
					if not same(v, a[k])
						return false
				else if a[k] ~= v
					return false
	
		return true
	return false

	
return {
	Stmt = Statement
	, Expr = Expression
	, bracket = bracket
	, same = same
}