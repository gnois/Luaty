var tree = require("lt.ast")
var scope = require("lt.scope")
var operator = require("lt.operator")
var Keyword = require("lt.reserved")

var LJ_52 = false

var EndOfChunk = { TK_dedent = true, TK_else = true, TK_until = true, TK_eof = true }
var EndOfFunction = { ['}'] = true, [')'] = true, [';'] = true, [','] = true} -- `,` is to end function within a table
var NewLine = { TK_newline = true }
-- expr kind
var Kind = { Expr = 1, Self = 2, Var = 3, Field = 4, Index = 5, Call = 6 }

-- disallow multiple statement on one line
-- need to be in file scope coz parse_chunk() is recursive
var stmted  -- keep the line number that we parsed

var is_keyword = \ls ->
	var str = ls.tostr(ls.token)
	if Keyword[str]
		return str


var err_syntax = \ls, em ->
	ls.error(ls, "%s", em)


var as_val = \ls ->
	if ls.value
		return "'" .. ls.value .. "'"


var err_instead = \ls, em, ... ->
	var msg = string.format(em, ...)
	ls.error(ls, "%s instead of %s", msg, as_val(ls) or ls.astext(ls.token))


var err_expect = \ls, token ->
	err_instead(ls, "%s expected", ls.astext(token))


var err_symbol = \ls ->
	var sym = ls.tostr(ls.token)
	var replace = {end = "<dedent>", local = "`var`", function = "\\...->", elseif = "`else if`", repeat = "`do`"}
	var rep = replace[sym]
	if rep
		ls.error(ls, "use %s instead of '%s'", rep, sym)
	else
		ls.error(ls, "unexpected %s", as_val(ls) or ls.astext(ls.token))


var lex_opt = \ls, tok ->
	if ls.token == tok
		ls.step()
		return true
	return false


var lex_check = \ls, tok ->
	if ls.token ~= tok
		err_expect(ls, tok) 
	ls.step()


var lex_match = \ls, what, who, line ->
	if not lex_opt(ls, what)
		if line == ls.line
			err_expect(ls, what)
		else
			err_instead(ls, "%s expected to match %s at line %d", ls.astext(what), ls.astext(who), line)


var lex_str = \ls ->
	var s
	if ls.token ~= 'TK_name' and (LJ_52 or ls.token ~= 'TK_goto')
		err_expect(ls, 'TK_name')
		-- no longer exiting, so cannot be nil
		s = ls.tostr(ls.token)
	else
		s = ls.value
	ls.step()
	return s


-- return true only if a real indent is eaten
var lex_indent = \ls ->
	if NewLine[ls.token] and ls.next() == 'TK_indent'
		lex_opt(ls, 'TK_newline')
		ls.step()
		return true
	return false


-- return true only if a real dedent is eaten
var lex_dedent = \ls ->
	if ls.token == 'TK_dedent' or NewLine[ls.token] and ls.next() == 'TK_dedent'
		lex_opt(ls, 'TK_newline')
		ls.step()
		return true
	return false


var lex_opt_dent = \ls, dented ->
	if not dented
		dented = lex_indent(ls)
	else
		dented = not lex_dedent(ls)
	lex_opt(ls, 'TK_newline')
	return dented


--- Expressions ------------------------------------------------
var expr_primary, expr, expr_unop, expr_binop, expr_simple, expr_list, expr_table
var parse_body, parse_args, parse_block, parse_opt_chunk

var var_name = \ast, ls ->
	var name = lex_str(ls)
	var vk = Kind.Var
	if name == 'self' or name == '@'
		vk = Kind.Self
	return ast.identifier(@, name), vk


var expr_field = \ast, ls, v ->
	ls.step() -- Skip dot or colon.
	var key = is_keyword(ls)
	if key
		ls.step()
		return ast.expr_index(@, v, ast.literal(@, key))

	key = lex_str(ls)
	return ast.expr_property(@, v, key), v, key


var expr_bracket = \ast, ls ->
	ls.step() -- Skip '['.
	var v = expr(ast, ls)
	lex_check(ls, ']')
	return v


expr_table = \ast, ls ->
	var line = ls.line
	var kvs = {}
	var dented = false
	lex_check(ls, '{')
	while ls.token ~= '}'
		dented = lex_opt_dent(ls, dented)
		-- catch common mistake that mess everything later
		if not dented and ls.token == 'TK_dedent'
			err_symbol(ls)
			ls.step()

		-- in case the table ends immediately
		if ls.token == '}'
			break
		var key
		if ls.token == '['
			key = expr_bracket(ast, ls)
			lex_check(ls, '=')
		else if ls.next() == '='
			if ls.token == 'TK_name' -- or (not LJ_52 and ls.token == 'TK_goto')    `goto` can be table key
				var name = lex_str(ls)
				key = ast.literal(@, name)
			else if ls.token == 'TK_string'
				key = ast.literal(@, ls.value)
				ls.step()
			else
				var name = is_keyword(ls)
				if name
					key = ast.literal(@, name)
					ls.step()
			lex_check(ls, '=')
	
		var val = expr(ast, ls)
		if key
			for i = 1, #kvs
				var arr = kvs[i]
				if ast.same(arr[2], key)
					err_syntax(ls, "duplicate key at position " .. i .. " and " .. (#kvs + 1) .. " in table")
	
		kvs[#kvs + 1] = { val, key }  -- key can be nil

		dented = lex_opt_dent(ls, dented)
		if ls.token == ';'
			err_instead(ls, "use %s", ls.astext(','))
		if not lex_opt(ls, ',') and not lex_opt(ls, ';')
			break

	if dented and not lex_dedent(ls)
		err_instead(ls, "%s expected to match %s at line %d", ls.astext('TK_dedent'), ls.astext('TK_indent'), line)
	lex_match(ls, '}', '{', line)
	return ast.expr_table(@, kvs, line)


var expr_function = \ast, ls ->
	var line = ls.line
	if ls.token == '\\'
		ls.step()
	var curry, args, body = parse_body(ast, ls, line)
	var lambda = ast.expr_function(@, args, body)
	if curry
		curry = ast.identifier(@, 'curry')
		var identifier = ast.in_scope(@, curry)
		if identifier ~= true
			err_syntax(ls, "`" .. identifier .. "()` is required for `~>`")

		var cargs = { ast.literal(@, #args), lambda }
		return ast.expr_function_call(@, curry, cargs, line)

	return lambda
  

expr_simple = \ast, ls ->
	var tk, val = ls.token, ls.value
	var e
	if tk == 'TK_number'
		e = ast.numberliteral(@, val)
	else if tk == 'TK_string'
		e = ast.literal(@, val)
	else if tk == 'TK_longstring'
		e = ast.longstrliteral(@, val)
	else if tk == 'TK_nil'
		e = ast.literal(@, nil)
	else if tk == 'TK_true'
		e = ast.literal(@, true)
	else if tk == 'TK_false'
		e = ast.literal(@, false)
	else if tk == '...'
		if not ast.scope.varargs
			err_syntax(ls, "cannot use `...` in a function without variable arguments")
		e = ast.expr_vararg(@)
	else if tk == '{'
		return expr_table(ast, ls)
	else if tk == '\\' or tk == '->' or tk == '~>'
		return expr_function(ast, ls)
	else
		return expr_primary(ast, ls)

	ls.step()
	return e


-- nmax checks the max number of expression expected
expr_list = \ast, ls, nmax ->
	var exps = {}
	exps[1] = expr(ast, ls)
	
	while ls.token == ','
		ls.step()
		exps[#exps + 1] = expr(ast, ls)

	var n = #exps
	if nmax and n > nmax
		err_syntax(ls, "assigning " .. n .. " values to " .. nmax .. " variable(s)")
	--if n > 0
	--	exps[n] = ast.set_expr_last(@, exps[n])
	return exps


expr_unop = \ast, ls ->
	var tk = ls.token
	if tk == 'TK_not' or tk == '-' or tk == '#'
		var line = ls.line
		ls.step()
		var v = expr_binop(ast, ls, operator.unary_priority)
		return ast.expr_unop(@, ls.tostr(tk), v, line)
	else
		return expr_simple(ast, ls)


-- Parse binary expressions with priority higher than the limit.
expr_binop = \ast, ls, limit ->
	var v, vk = expr_unop(ast, ls)
	var op = ls.tostr(ls.token)
	while operator.is_binop(op) and operator.left_priority(op) > limit
		var line = ls.line
		ls.step()
		var v2, nextop = expr_binop(ast, ls, operator.right_priority(op))
		v = ast.expr_binop(@, op, v, v2, line)
		op = nextop
		vk = nil

	return v, op, vk


expr = \ast, ls ->
	return expr_binop(ast, ls, 0) -- Priority 0: parse whole expression.


-- Parse primary and prefix expression
expr_primary = \ast, ls ->
	var v, vk
	if ls.token == '('
		var line = ls.line
		ls.step()
		vk, v = Kind.Expr, ast.expr_brackets(@, expr(ast, ls))
		lex_match(ls, ')', '(', line)
	else --if ls.token == 'TK_name' or (not LJ_52 and ls.token == 'TK_goto')    -- comment out coz err_symbol() will not quit, and v will be nil
		v, vk = var_name(ast, ls)
	--else
	--	err_symbol(ls)

	var val, key
	while true -- Parse multiple expression suffixes
		var line = ls.line
		if ls.token == '.'
			vk, v, val, key = Kind.Field, expr_field(ast, ls, v)
		else if ls.token == '['
			key = expr_bracket(ast, ls)
			val = v
			vk, v = Kind.Index, ast.expr_index(@, val, key)
		else if ls.token == '(' -- or ls.token == 'TK_string' or ls.token == '{'
			var args, self1 = parse_args(ast, ls)
			if self1 and (vk == Kind.Field or vk == Kind.Index)
				table.remove(args, 1)
				if vk == Kind.Field
					vk, v = Kind.Call, ast.expr_method_call(@, val, key, args, line)
				else if vk == Kind.Index
					-- simulate a wrapped self method call
					var nm = '_0'   -- lets hope we dont name clash
					var obj = ast.identifier(@, nm)
					table.insert(args, 1, obj)
					var body = {
						ast.local_decl(@, {ast.var_declare(@, nm)}, {val}, line)
						, ast.return_stmt(@, {
							ast.expr_function_call(@, ast.expr_index(@, obj, key), args, line)
						}, line)
					}
					var lambda = ast.expr_function(@, {}, body, { varargs = false })
					vk, v = Kind.Call, ast.expr_function_call(@, lambda, {}, line)
			else
				vk, v = Kind.Call, ast.expr_function_call(@, v, args, line)
		else
			break

	return v, vk


--- Statements ------------------------------------------------

var parse_return = \ast, ls, line ->
	ls.step() -- skip 'return'
	ast.has_return = true
	var exps
	if EndOfChunk[ls.token] or NewLine[ls.token] or EndOfFunction[ls.token]  -- or ls.token == ';'
		exps = {}
	else -- return with one or more values
		exps = expr_list(ast, ls)
	return ast.return_stmt(@, exps, line)


-- Parse numeric 'for'
var parse_for_num = \ast, ls, varname, line ->
	lex_check(ls, '=')
	var init = expr(ast, ls)
	lex_check(ls, ',')
	var last = expr(ast, ls)
	var step
	if lex_opt(ls, ',')
		step = expr(ast, ls)
	else
		step = ast.literal(@, 1)
	
	scope.enter_block(ast.scope)  -- scope for visible var
	var v = ast.var_declare(@, varname)  -- add to scope
	var body = parse_block(ast, ls, line, 'TK_for')
	scope.leave_block(ast.scope)
	return ast.for_stmt(@, v, init, last, step, body, line, ls.line)


-- Parse 'for' iterator
var parse_for_iter = \ast, ls, indexname ->
	scope.enter_block(ast.scope)  -- scope for visible var
	var vars = { ast.var_declare(@, indexname) }
	while lex_opt(ls, ',')
		indexname = lex_str(ls)
		vars[#vars + 1] = ast.var_declare(@, indexname)

	lex_check(ls, 'TK_in')
	var line = ls.line
	var exps = expr_list(ast, ls)
	var body = parse_block(ast, ls, line, 'TK_for')
	scope.leave_block(ast.scope)
	return ast.for_iter_stmt(@, vars, exps, body, line, ls.line)


-- Parse 'for' statement
var parse_for = \ast, ls, line ->
	ls.step()  -- Skip 'for'.
	scope.enter_block(ast.scope, true)
	var varname = lex_str(ls)  -- Get first variable name.
	var stmt
	if ls.token == '='
		stmt = parse_for_num(ast, ls, varname, line)
	else if ls.token == ',' or ls.token == 'TK_in'
		stmt = parse_for_iter(ast, ls, varname)
	else
		err_instead(ls, "%s expected", "`=` or `in`")
	scope.leave_block(ast.scope)
	return stmt


-- Parse function call argument list.
parse_args = \ast, ls ->
	var line = ls.line
	lex_check(ls, '(')
	if not LJ_52 and line ~= ls.prevline
		err_syntax(ls, "ambiguous syntax (function call x new statement)")

	var dented = false
	var self1, vk = false
	var args, n = {}, 0
	while ls.token ~= ')'
		dented = lex_opt_dent(ls, dented)
		-- catch common mistake that mess everything later
		if not dented and ls.token == 'TK_dedent'
			err_symbol(ls)
			ls.step()
			
		if ls.token == ')'
			break
		n = n + 1
		args[n], _, vk = expr(ast, ls)
		if n == 1 and vk == Kind.Self
			self1 = true
		
		dented = lex_opt_dent(ls, dented)
		if not lex_opt(ls, ',')
			break
		
	if dented and not lex_dedent(ls)
		err_instead(ls, "%s expected to match %s at line %d", ls.astext('TK_dedent'), ls.astext('TK_indent'), line)
	lex_match(ls, ')', '(', line)

	--if n > 0
	--	args[n] = ast.set_expr_last(@, args[n])
	return args, self1


var parse_assignment
parse_assignment = \ast, ls, vlist, v, vk ->
	var line = ls.line
	if vk ~= Kind.Var and vk ~= Kind.Self and vk ~= Kind.Field and vk ~= Kind.Index
		err_symbol(ls)

	vlist[#vlist+1] = v
	if lex_opt(ls, ',')
		var n_var, n_vk = expr_primary(ast, ls)
		return parse_assignment(ast, ls, vlist, n_var, n_vk)
	else -- Parse RHS.
		lex_check(ls, '=')
		if (vk == Kind.Var or vk == Kind.Self) 
			var identifier = ast.in_scope(@, v)
			if identifier ~= true
				err_syntax(ls, "undeclared identifier `" .. identifier .. "`")

		var exps = expr_list(ast, ls, #vlist)
		return ast.assignment_expr(@, vlist, exps, line)



var parse_call_assign = \ast, ls ->
	var v, vk = expr_primary(ast, ls)
	if vk == Kind.Call
		return ast.new_statement_expr(@, v, ls.line)
	else
		var vlist = {}
		return parse_assignment(ast, ls, vlist, v, vk)


var parse_var = \ast, ls ->
	var line = ls.line
	var lhs = {}
	repeat
		var name = lex_str(ls)
		--if ast.in_scope(@, v)
		--	err_syntax(ls, "shadowing previous `var " .. name .. "`")
		var v = ast.var_declare(@, name)
		lhs[#lhs+1] = v
	until not lex_opt(ls, ',')

	var rhs -- optional rhs
	if lex_opt(ls, '=')
		rhs = expr_list(ast, ls, #lhs)
	else
		rhs = {}
	return ast.local_decl(@, lhs, rhs, line)


var parse_while = \ast, ls, line ->
	ls.step() -- Skip 'while'
	var cond = expr(ast, ls)
	scope.enter_block(ast.scope, true)  -- loop block
	var body = parse_block(ast, ls, line, 'TK_while')
	scope.leave_block(ast.scope)
	var lastline = ls.line
	return ast.while_stmt(@, cond, body, line, lastline)


var parse_then = \ast, ls, tests, line ->
	ls.step()
	tests[#tests+1] = expr(ast, ls)
	if ls.token == 'TK_then'
		err_syntax(ls, "`then` is not needed")
		ls.step()
	return parse_block(ast, ls, line, 'TK_if')


var parse_if = \ast, ls, line ->
	var tests, blocks = {}, {}
	blocks[#blocks+1] = parse_then(ast, ls, tests, line)
	var else_branch
	while ls.token == 'TK_else' or NewLine[ls.token] and ls.next() == 'TK_else'
		lex_opt(ls, 'TK_newline')
		ls.step()
		if ls.token == 'TK_if'
			blocks[#blocks+1] = parse_then(ast, ls, tests, line)
		else
			else_branch = parse_block(ast, ls, ls.line, 'TK_else')
			break
	return ast.if_stmt(@, tests, blocks, else_branch, line)


var parse_do = \ast, ls, line ->
	ls.step() -- Skip 'do'
	var body = parse_block(ast, ls, line, 'TK_do')
	var lastline = ls.line
	return ast.do_stmt(@, body, line, lastline)


var parse_repeat = \ast, ls, line ->
	ls.step()  -- skip repeat
	scope.enter_block(ast.scope, true) -- loop block
	scope.enter_block(ast.scope)       -- scope block
	var body, _, lastline = parse_opt_chunk(ast, ls, line, 'TK_repeat')
	lex_match(ls, 'TK_until', 'TK_repeat', line)
	var cond = expr(ast, ls) -- until condition
	scope.leave_block(ast.scope)   -- finish scope after `until`
	scope.leave_block(ast.scope)   -- finish loop block
	return ast.repeat_stmt(@, cond, body, line, lastline)


var parse_label
parse_label = \ast, ls ->
	ls.step() -- Skip '::'
	var name = lex_str(ls)
	lex_check(ls, '::')
	return ast.label_stmt(@, name, ls.line)


var parse_goto = \ast, ls ->
	var line = ls.line
	var name = lex_str(ls)
	return ast.goto_stmt(@, name, line)


-- Parse a statement. Returns the statement itself and a boolean that tells if it
-- must be the last one in a chunk.
var parse_stmt
parse_stmt = \ast, ls ->
	var line = ls.line
	var stmt
	if ls.token == 'TK_if'
		stmt = parse_if(ast, ls, line)
	else if ls.token == 'TK_for'
		stmt = parse_for(ast, ls, line)
	else if ls.token == 'TK_while'
		stmt = parse_while(ast, ls, line)
	else if ls.token == 'TK_do'
		stmt = parse_do(ast, ls, line)
	else if ls.token == 'TK_repeat'
		stmt = parse_repeat(ast, ls, line)
	--else if ls.token == 'TK_function'
	--	stmt = parse_func(ast, ls, line)
	else if ls.token == '->' or ls.token == '~>'
		err_syntax(ls, "lambda must either be assigned or invoked")
	else if ls.token == 'TK_name' and ls.value == 'var'
		ls.step()
		stmt = parse_var(ast, ls, line)
	else if ls.token == 'TK_local'
		err_symbol(ls)
		ls.step()
		stmt = parse_var(ast, ls, line)
	else if ls.token == 'TK_return'
		stmt = parse_return(ast, ls, line)
		return stmt, true -- Must be last
	else if ls.token == 'TK_break'
		ls.step()
		stmt = ast.break_stmt(@, line)
		return stmt, not LJ_52 -- Must be last in Lua 5.1
	else if ls.token == '::'
		stmt = parse_label(ast, ls)
	else if ls.token == 'TK_goto'
		if LJ_52 or ls.next() == 'TK_name'
			ls.step()
			stmt = parse_goto(ast, ls)
		-- else fall thru
		
	-- is TK_name, must be function call or assignment
	if not stmt
		stmt = parse_call_assign(ast, ls)
	return stmt, false


-- a chunk is a list of statements, regardless of scope
var parse_chunk = \ast, ls ->
	
	var skip_ends = \ls ->
		while ls.token == ';' or ls.token == 'TK_end'
			err_symbol(ls)
			ls.step()
		lex_opt(ls, 'TK_newline')
		
	var firstline = ls.line
	var stmt, islast = nil, false
	var body = {}
	while not islast and not EndOfChunk[ls.token]
		stmted = ls.line
		skip_ends(ls)
		stmt, islast = parse_stmt(ast, ls)
		body[#body + 1] = stmt
		skip_ends(ls)
		-- disallow multiple statement in one line
		if stmted == ls.line
			if ls.token ~= 'TK_eof' and ls.token ~= 'TK_dedent' and ls.next() ~= 'TK_eof'
				err_instead(ls, "only one statement allowed per line. %s expected", ls.astext('TK_newline'))
	return body, firstline, ls.line


-- parse indented single or list of statements, regardless of scope
parse_opt_chunk = \ast, ls, line, match_token ->
	var body = {}
	if lex_indent(ls)
		body = parse_chunk(ast, ls)
		--lex_match(ls, 'TK_dedent', match_token, line)
		if not lex_dedent(ls)
			err_instead(ls, "%s expected to end %s at line %d", ls.astext('TK_dedent'), ls.astext(match_token), line)
	else
		if not EndOfChunk[ls.token] and not NewLine[ls.token] and not EndOfFunction[ls.token]
			-- single statement
			body[1] = parse_stmt(ast, ls)
			--body.firstline, body.lastline = line, ls.line

		if not EndOfChunk[ls.token] and not NewLine[ls.token] and not EndOfFunction[ls.token]
			err_instead(ls, "only one statement may stay near %s. %s expected", ls.astext(match_token), ls.astext('TK_newline'))
		-- returning multiple values need ; if it stays with other expressions on the same line
		else if EndOfFunction[ls.token]
			lex_opt(ls, ';')
	return body


parse_block = \ast, ls, line, match ->
	scope.enter_block(ast.scope)
	var chunk = parse_opt_chunk(ast, ls, line, match)
	scope.leave_block(ast.scope)
	return chunk


-- Parse function definition parameters
var parse_params = \ast, ls ->
	var args = {}
	if ls.token ~= '->' and ls.token ~= '~>'
		repeat
			if ls.token == 'TK_name' or (not LJ_52 and ls.token == 'TK_goto')
				var name = lex_str(ls)
				args[#args+1] = ast.var_declare(@, name)
			else if ls.token == '...'
				ls.step()
				ast.scope.varargs = true
				args[#args + 1] = ast.expr_vararg(@)
				break
			else
				err_instead(ls, "parameter expected for %s", ls.astext('->'))
		until not lex_opt(ls, ',')

	if ls.token == '->'
		ls.step()
		return false, args
	else if ls.token == '~>'
		if ast.scope.varargs
			err_syntax(ls, "cannot curry variadic parameters with `~>`")
		if #args < 2
			err_syntax(ls, "at least 2 parameters needed with `~>`")
		ls.step()
		return true, args
	err_expect(ls, '->')


-- Parse body of a function
parse_body = \ast, ls, line ->
	ast.scope = scope.begin_func(ast.scope)
	var curry, args = parse_params(ast, ls)
	var body = parse_opt_chunk(ast, ls, line, '->')
	ast.scope = scope.end_func(ast.scope)
	return curry, args, body, ast.scope.varargs


var parse = \ls ->
	ls.step()
	lex_opt(ls, 'TK_newline')
	var ast = tree.New()
	-- main chunk is always a vararg function
	ast.scope = scope.begin_func(nil)
	ast.scope.varargs = true
	var chunk, _, lastline = parse_chunk(ast, ls)
	ast.scope = scope.end_func(ast.scope)
	assert(ast.scope == nil)
	if ls.token ~= 'TK_eof'
		err_syntax(ls, "code should end. unexpected extra " .. ls.astext(ls.token))
	return ast.chunk(@, chunk, ls.chunkname, 0, lastline)


return parse
