var operator = require("lt.operator")
var Keyword = require("lt.reserved")
Keyword.var = true

var LJ_52 = false

var EndOfBlock = { TK_dedent = true, TK_else = true, TK_until = true, TK_eof = true }
var EndOfFunction = { ['}'] = true, [')'] = true, [';'] = true, [','] = true} -- `,` is to end function within a table
var NewLine = { TK_newline = true }

-- disallow multiple statement on one line
-- need to be in file scope coz parse_block_stmts() is recursive
var stmted  -- keep the line number that we parsed

var is_keyword = \ls ->
	var str = ls.tostr(ls.token)
	if Keyword[str]
		return str

var err_syntax = \ls, em ->
	ls.error(ls, "%s", em)


var err_instead = \ls, em, ... ->
	var msg = string.format(em, ...)
	ls.error(ls, "%s instead of '%s'", msg, ls.value or ls.tostr(ls.token))


var err_token = \ls, token ->
	err_instead(ls, "'%s' expected", ls.tostr(token))


var err_symbol = \ls ->
	var sym = ls.value or ls.tostr(ls.token)
	var replace = {['end'] = "<dedent>", ['local'] = "'var'", ['function'] = "\\...->", ['elseif'] = "'else if'", ['repeat'] = "'do'"}
	var rep = replace[sym]
	if rep
		ls.error(ls, "use %s instead of '%s'", rep, sym)
	else
		ls.error(ls, "unexpected %s", sym)


var lex_opt = \ls, tok ->
	if ls.token == tok
		ls.step()
		return true
	return false


var lex_check = \ls, tok ->
	if ls.token ~= tok
		err_token(ls, tok) 
	ls.step()


var lex_match = \ls, what, who, line ->
	if not lex_opt(ls, what)
		if line == ls.line
			err_token(ls, what)
		else
			err_instead(ls, "'%s' expected to match '%s' at line %d", ls.tostr(what), ls.tostr(who), line)


var lex_str = \ls ->
	if ls.token ~= 'TK_name' and (LJ_52 or ls.token ~= 'TK_goto')
		err_token(ls, 'TK_name')

	var s = ls.value
	ls.step()
	return s


-- return true only if a real indent is eaten
var lex_indent = \ls ->
	if NewLine[ls.token] and ls.next() == 'TK_indent'
		lex_opt(ls, 'TK_newline')
		ls.step()
		return true
	return false


-- return true only if a real dedent is eaten
var lex_dedent = \ls ->
	if ls.token == 'TK_dedent' or NewLine[ls.token] and ls.next() == 'TK_dedent'
		lex_opt(ls, 'TK_newline')
		ls.step()
		return true
	return false


var lex_opt_dent = \ls, dented ->
	if not dented
		dented = lex_indent(ls)
	else
		dented = not lex_dedent(ls)
	lex_opt(ls, 'TK_newline')
	return dented


--- Expressions ------------------------------------------------
var expr_primary, expr, expr_unop, expr_binop, expr_simple, expr_list, expr_table
var parse_body, parse_args, parse_block, parse_opt_block

var var_name = \ast, ls ->
	var name = lex_str(ls)
	return ast.identifier(@, name)


var expr_field = \ast, ls, v ->
	ls.step() -- Skip dot or colon.
	var key = is_keyword(ls)
	if key
		ls.step()
		if key == "var"  -- `var` is not a Lua keyword
			return ast.expr_property(@, v, key)
	
		return ast.expr_index(@, v, ast.literal(@, key))

	key = lex_str(ls)
	return ast.expr_property(@, v, key)


var expr_bracket = \ast, ls ->
	ls.step() -- Skip '['.
	var v = expr(ast, ls)
	lex_check(ls, ']')
	return v


expr_table = \ast, ls ->
	var line = ls.line
	var kvs = {}
	var dented = false
	lex_check(ls, '{')
	while ls.token ~= '}'
		dented = lex_opt_dent(ls, dented)
		-- in case the table ends immediately
		if ls.token == '}'
			break
	
		var key
		if ls.token == '['
			key = expr_bracket(ast, ls)
			lex_check(ls, '=')
		else if ls.next() == '='
			if ls.token == 'TK_name' -- or (not LJ_52 and ls.token == 'TK_goto')    `goto` can be table key
				var name = lex_str(ls)
				key = ast.literal(@, name)
			else if ls.token == 'TK_string'
				key = ast.literal(@, ls.value)
				ls.step()
			else
				var name = is_keyword(ls)
				if name
					key = ast.literal(@, name)
					ls.step()
			lex_check(ls, '=')
	
		var val = expr(ast, ls)
		if key
			for i = 1, #kvs
				var arr = kvs[i]
				if ast.same(arr[2], key)
					err_syntax(ls, "duplicate key at position " .. i .. " and " .. (#kvs + 1) .. " in table")
	
		kvs[#kvs + 1] = { val, key }  -- key can be nil

		dented = lex_opt_dent(ls, dented)
		if not lex_opt(ls, ',')
			break

	if dented and not lex_dedent(ls)
		err_instead(ls, "'%s' expected to match '%s' at line %d", ls.tostr('TK_dedent'), ls.tostr('TK_indent'), line)
	lex_match(ls, '}', '{', line)
	return ast.expr_table(@, kvs, line)


expr_simple = \ast, ls ->
	var tk, val = ls.token, ls.value
	var e
	if tk == 'TK_number'
		e = ast.numberliteral(@, val)
	else if tk == 'TK_string'
		e = ast.literal(@, val)
	else if tk == 'TK_longstring'
		e = ast.longstrliteral(@, val)
	else if tk == 'TK_nil'
		e = ast.literal(@, nil)
	else if tk == 'TK_true'
		e = ast.literal(@, true)
	else if tk == 'TK_false'
		e = ast.literal(@, false)
	else if tk == 'TK_dots'
		if not ls.fs.varargs
			err_syntax(ls, "cannot use `...` outside a vararg function")
	
		e = ast.expr_vararg(@)
	else if tk == '{'
		return expr_table(ast, ls)
	else if tk == '\\' or tk == 'TK_lambda'
		if tk == '\\'
			ls.step()
	
		var curry, args, body, proto = parse_body(ast, ls, ls.line)
		var lambda = ast.expr_function(@, args, body, proto)
		if curry
			curry = ast.identifier(@, 'curry')
			if not ast.in_scope(@, curry)
				err_syntax(ls, curry.name .. "() is required for ~>")
		
			var cargs = { ast.literal(@, #args), lambda }
			return ast.expr_function_call(@, curry, cargs, ls.line)
	
		return lambda
	else if tk == 'TK_curry'
		err_syntax(ls, "no argument to curry with ~>")
	else
		return expr_primary(ast, ls)

	ls.step()
	return e


-- nmax checks the max number of expression expected
expr_list = \ast, ls, nmax ->
	var exps = {}
	exps[1] = expr(ast, ls)
	
	while ls.token == ','
		ls.step()
		exps[#exps + 1] = expr(ast, ls)

	var n = #exps
	if nmax and n > nmax
		err_syntax(ls, "assigning " .. n .. " values to " .. nmax .. " variable(s)")
	if n > 0
		exps[n] = ast.set_expr_last(@, exps[n])
	return exps


expr_unop = \ast, ls ->
	var tk = ls.token
	if tk == 'TK_not' or tk == '-' or tk == '#'
		var line = ls.line
		ls.step()
		var v = expr_binop(ast, ls, operator.unary_priority)
		return ast.expr_unop(@, ls.tostr(tk), v, line)
	else
		return expr_simple(ast, ls)


-- Parse binary expressions with priority higher than the limit.
expr_binop = \ast, ls, limit ->
	var v = expr_unop(ast, ls)
	var op = ls.tostr(ls.token)
	while operator.is_binop(op) and operator.left_priority(op) > limit
		var line = ls.line
		ls.step()
		var v2, nextop = expr_binop(ast, ls, operator.right_priority(op))
		v = ast.expr_binop(@, op, v, v2, line)
		op = nextop

	return v, op


expr = \ast, ls ->
	return expr_binop(ast, ls, 0) -- Priority 0: parse whole expression.


-- Parse primary expression.
expr_primary = \ast, ls ->
	var v, vk
	-- Parse prefix expression.
	if ls.token == '('
		var line = ls.line
		ls.step()
		vk, v = 'expr', ast.expr_brackets(@, expr(ast, ls))
		lex_match(ls, ')', '(', line)
	else if ls.token == 'TK_name' or (not LJ_52 and ls.token == 'TK_goto')
		vk, v = 'var', var_name(ast, ls)
	else
		err_symbol(ls)

	var key
	while true -- Parse multiple expression suffixes.
		var line = ls.line
		if ls.token == '.'
			vk, v = 'indexed', expr_field(ast, ls, v)
		else if ls.token == '['
			key = expr_bracket(ast, ls)
			vk, v = 'indexed', ast.expr_index(@, v, key)
		else if ls.token == ':'
			err_syntax(ls, "use of `:` is not supported")
		else if ls.token == '(' -- or ls.token == 'TK_string' or ls.token == '{'
			var args = parse_args(ast, ls)
			-- if vk is indexed and first argument is @, it is a method call
			if vk == 'indexed' and args[1] and args[1].kind == 'Identifier' and args[1].name == 'self'
				table.remove(args, 1)
				vk, v = 'call', ast.expr_method_call(@, v, args, line)
			else
				vk, v = 'call', ast.expr_function_call(@, v, args, line)
		else
			break

	return v, vk


--- Statements ------------------------------------------------

-- Parse 'return' statement.
var parse_return = \ast, ls, line ->
	ls.step() -- Skip 'return'.
	ls.fs.has_return = true
	var exps
	if EndOfBlock[ls.token] or NewLine[ls.token] or EndOfFunction[ls.token]  -- or ls.token == ';'
		exps = {}
	else -- Return with one or more values
		exps = expr_list(ast, ls)
	return ast.return_stmt(@, exps, line)


-- Parse numeric 'for'.
var parse_for_num = \ast, ls, varname, line ->
	ast.fscope_begin(@)
	lex_check(ls, '=')
	var init = expr(ast, ls)
	lex_check(ls, ',')
	var last = expr(ast, ls)
	var step
	if lex_opt(ls, ',')
		step = expr(ast, ls)
	else
		step = ast.literal(@, 1)

	var v = ast.identifier(@, varname)
	ast.var_declare(@, varname)  -- add to scope
	var body = parse_opt_block(ast, ls, line, 'TK_for')
	ast.fscope_end(@)
	return ast.for_stmt(@, v, init, last, step, body, line, ls.line)


-- Parse 'for' iterator.
var parse_for_iter = \ast, ls, indexname ->
	ast.fscope_begin(@)
	var vars = { ast.identifier(@, indexname) }
	ast.var_declare(@, indexname)
	while lex_opt(ls, ',')
		indexname = lex_str(ls)
		vars[#vars + 1] = ast.identifier(@, indexname)
		ast.var_declare(@, indexname)

	lex_check(ls, 'TK_in')
	var line = ls.line
	var exps = expr_list(ast, ls)
	var body = parse_opt_block(ast, ls, line, 'TK_for')
	ast.fscope_end(@)
	return ast.for_iter_stmt(@, vars, exps, body, line, ls.line)


-- Parse 'for' statement.
var parse_for = \ast, ls, line ->
	ls.step()  -- Skip 'for'.
	var varname = lex_str(ls)  -- Get first variable name.
	var stmt
	if ls.token == '='
		stmt = parse_for_num(ast, ls, varname, line)
	else if ls.token == ',' or ls.token == 'TK_in'
		stmt = parse_for_iter(ast, ls, varname)
	else
		err_instead(ls, "%s expected", "'=' or 'in'")

	return stmt


-- Parse function call argument list.
parse_args = \ast, ls ->
	var line = ls.line
	lex_check(ls, '(')
	if not LJ_52 and line ~= ls.prevline
		err_syntax(ls, "ambiguous syntax (function call x new statement)")

	var dented = false
	var args = {}
	while ls.token ~= ')'
		dented = lex_opt_dent(ls, dented)
		if ls.token == ')'
			break
		args[#args + 1] = expr(ast, ls)
		
		dented = lex_opt_dent(ls, dented)
		if not lex_opt(ls, ',')
			break
		
	if dented and not lex_dedent(ls)
		err_instead(ls, "'%s' expected to match '%s' at line %d", ls.tostr('TK_dedent'), ls.tostr('TK_indent'), line)
	lex_match(ls, ')', '(', line)

	var n = #args
	if n > 0
		args[n] = ast.set_expr_last(@, args[n])
	return args


var parse_assignment
parse_assignment = \ast, ls, vlist, v, vk ->
	var line = ls.line
	if vk ~= 'var' and vk ~= 'indexed'
		err_symbol(ls)

	vlist[#vlist+1] = v
	if lex_opt(ls, ',')
		var n_var, n_vk = expr_primary(ast, ls)
		return parse_assignment(ast, ls, vlist, n_var, n_vk)
	else -- Parse RHS.
		lex_check(ls, '=')
		if vk == 'var' and not ast.in_scope(@, v)
			err_syntax(ls, "undeclared identifier " .. v.name)
	
		var exps = expr_list(ast, ls, #vlist)
		return ast.assignment_expr(@, vlist, exps, line)



var parse_call_assign = \ast, ls ->
	var v, vk = expr_primary(ast, ls)
	if vk == 'call'
		return ast.new_statement_expr(@, v, ls.line)
	else
		var vlist = {}
		return parse_assignment(ast, ls, vlist, v, vk)


-- Parse 'var' statement.
var parse_var = \ast, ls ->
	var line = ls.line
	var vl = {}
	do -- Collect LHS.
		vl[#vl+1] = lex_str(ls)
	until not lex_opt(ls, ',')
	var v = ast.overwritten(@, vl)
	if v
		err_syntax(ls, "shadowing previous `var " .. v .. "`")

	var exps
	if lex_opt(ls, '=') -- Optional RHS.
		exps = expr_list(ast, ls, #vl)
	else
		exps = {}
	return ast.local_decl(@, vl, exps, line)


var parse_while = \ast, ls, line ->
	ls.step() -- Skip 'while'.
	ast.fscope_begin(@)
	var cond = expr(ast, ls)
	var body = parse_opt_block(ast, ls, line, 'TK_while')
	var lastline = ls.line
	ast.fscope_end(@)
	return ast.while_stmt(@, cond, body, line, lastline)


var parse_if = \ast, ls, line ->
	var tests, blocks = {}, {}
	ls.step()
	tests[#tests+1] = expr(ast, ls)
	ast.fscope_begin(@)
	blocks[1] = parse_opt_block(ast, ls, line, 'TK_if')
	ast.fscope_end(@)
	var else_branch
	while ls.token == 'TK_else' or NewLine[ls.token] and ls.next() == 'TK_else'
		lex_opt(ls, 'TK_newline')
		ls.step()
		if ls.token == 'TK_if'
			ls.step()
			tests[#tests+1] = expr(ast, ls)
			ast.fscope_begin(@)
			blocks[#blocks+1] = parse_opt_block(ast, ls, ls.line, 'TK_if')
			ast.fscope_end(@)
		else
			ast.fscope_begin(@)
			else_branch = parse_opt_block(ast, ls, ls.line, 'TK_else')
			ast.fscope_end(@)
			break

	return ast.if_stmt(@, tests, blocks, else_branch, line)


var parse_do = \ast, ls, line ->
	ls.step() -- Skip 'do'
	ast.fscope_begin(@)
	var body = parse_opt_block(ast, ls, line, 'TK_do')
	var lastline = ls.line
	if lex_opt(ls, 'TK_until')
		var cond = expr(ast, ls) -- until condition.
		ast.fscope_end(@)
		return ast.repeat_stmt(@, cond, body, line, lastline)
	else
		ast.fscope_end(@)
		return ast.do_stmt(@, body, line, lastline)


var parse_label = \ast, ls ->
	ls.step() -- Skip '::'.
	var name = lex_str(ls)
	lex_check(ls, 'TK_label')
	-- Recursively parse trailing statements: labels and ';' (Lua 5.2 only).
	while true
		if ls.token == 'TK_label'
			parse_label(ast, ls)
		--else if LJ_52 and ls.token == ';'
		--    ls.step()
		else
			break
	return ast.label_stmt(@, name, ls.line)


var parse_goto = \ast, ls ->
	var line = ls.line
	var name = lex_str(ls)
	return ast.goto_stmt(@, name, line)


-- Parse a statement. Returns the statement itself and a boolean that tells if it
-- must be the last one in a chunk.
var parse_stmt = \ast, ls ->
	var line = ls.line
	var stmt
	if ls.token == 'TK_if'
		stmt = parse_if(ast, ls, line)
	else if ls.token == 'TK_while'
		stmt = parse_while(ast, ls, line)
	else if ls.token == 'TK_do'
		stmt = parse_do(ast, ls, line)
	else if ls.token == 'TK_for'
		stmt = parse_for(ast, ls, line)
	--else if ls.token == 'TK_repeat'
	--    stmt = parse_repeat(ast, ls, line)
	--else if ls.token == 'TK_function'
	--    stmt = parse_func(ast, ls, line)
	else if ls.token == 'TK_lambda' or ls.token == 'TK_curry'
		err_syntax(ls, "lambda must either be assigned or invoked")
	else if ls.token == 'TK_var'
		ls.step()
		stmt = parse_var(ast, ls, line)
	else if ls.token == 'TK_return'
		stmt = parse_return(ast, ls, line)
		return stmt, true -- Must be last.
	else if ls.token == 'TK_break'
		ls.step()
		stmt = ast.break_stmt(@, line)
		return stmt, not LJ_52 -- Must be last in Lua 5.1.
	--else if LJ_52 and ls.token == ';'
	--    ls.step()
	--    return parse_stmt(ast, ls)
	else if ls.token == 'TK_label'
		stmt = parse_label(ast, ls)
	else if ls.token == 'TK_goto'
		if LJ_52 or ls.next() == 'TK_name'
			ls.step()
			stmt = parse_goto(ast, ls)

	-- If here 'stmt' is "nil" then ls.token didn't match any of the previous rules.
	-- Fall back to call/assign rule.
	if not stmt
		stmt = parse_call_assign(ast, ls)
	return stmt, false


-- Parse function definition parameters
var parse_params = \ast, ls ->
	var args = {}
	if ls.token ~= 'TK_lambda' and ls.token ~= 'TK_curry'
		do
			if ls.token == 'TK_name' or (not LJ_52 and ls.token == 'TK_goto')
				var name = lex_str(ls)
				args[#args+1] = ast.var_declare(@, name)
			else if ls.token == 'TK_dots'
				ls.step()
				ls.fs.varargs = true
				args[#args + 1] = ast.expr_vararg(@)
				break
			else
				err_instead(ls, "%s argument expected", ls.tostr('TK_lambda'))
		
		until not lex_opt(ls, ',')

	if ls.token == 'TK_lambda'
		ls.step()
		return false, args
	else if ls.token == 'TK_curry'
		if ls.fs.varargs
			err_syntax(ls, "cannot curry varargs with ~>")
	
		if #args < 2
			err_syntax(ls, "at least 2 arguments needed with ~>")
	
		ls.step()
		return true, args
	err_token(ls, "->")


var parse_block_stmts = \ast, ls ->
	var firstline = ls.line
	var stmt, islast = nil, false
	var body = {}
	while not islast and not EndOfBlock[ls.token]
		stmted = ls.line
		stmt, islast = parse_stmt(ast, ls)
		body[#body + 1] = stmt
		lex_opt(ls, 'TK_newline')
		-- deliberately disallow multiple statement in one line
		if stmted == ls.line
			if ls.token ~= 'TK_eof' and ls.token ~= 'TK_dedent' and ls.next() ~= 'TK_eof'
				err_instead(ls, "only one statement allowed per line. %s expected", ls.tostr('TK_newline'))

	return body, firstline, ls.line


var parse_chunk = \ast, ls ->
	var body, firstline, lastline = parse_block_stmts(ast, ls)
	return ast.chunk(@, body, ls.chunkname, 0, lastline)


-- parse single or indented compound statement
parse_opt_block = \ast, ls, line, match_token ->
	var body = {}
	if lex_indent(ls)
		body = parse_block(ast, ls, line)
		--lex_match(ls, 'TK_dedent', match_token, line)
		if not lex_dedent(ls)
			err_instead(ls, "'%s' expected to end %s at line %d", ls.tostr('TK_dedent'), ls.tostr(match_token), line)
	else
		if not EndOfBlock[ls.token] and not NewLine[ls.token] and not EndOfFunction[ls.token]
			-- single statement
			body[1] = parse_stmt(ast, ls)
			body.firstline, body.lastline = line, ls.line
		-- if lookahead is indent, it belongs to parent block
		--if NewLine[ls.token] and ls.next() ~= 'TK_indent'
		--	ls.step()
		if not EndOfBlock[ls.token] and not NewLine[ls.token] and not EndOfFunction[ls.token]
			err_instead(ls, "only one statement may stay near '%s'. %s expected", ls.tostr(match_token), ls.tostr('TK_newline'))
	return body


-- Parse body of a function
parse_body = \ast, ls, line ->
	var pfs = ls.fs
	ls.fs = { varargs = false }
	ast.fscope_begin(@)
	ls.fs.firstline = line
	var curry, args = parse_params(ast, ls)
	var body = parse_opt_block(ast, ls, line, 'TK_lambda')
	-- end of function
	lex_opt(ls, ';')
	ast.fscope_end(@)
	var proto = ls.fs
	ls.fs.lastline = ls.line
	ls.fs = pfs
	return curry, args, body, proto


parse_block = \ast, ls, firstline ->
	--ast.fscope_begin(@)
	var body = parse_block_stmts(ast, ls)
	body.firstline, body.lastline = firstline, ls.line
	--ast.fscope_end(@)
	return body


var parse = \ast, ls ->
	ls.step()
	lex_opt(ls, 'TK_newline')
	ls.fs = { varargs = false }
	ast.fscope_begin(@)
	var args = { ast.expr_vararg(@, ast) }
	var chunk = parse_chunk(ast, ls)
	ast.fscope_end(@)
	--lex_check(ls, 'TK_eof')
	-- give better message
	if ls.token ~= 'TK_eof'
		err_syntax(ls, "unexpected extra `" .. ls.tostr(ls.token) .. "`")
	return chunk


return parse
