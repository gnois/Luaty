var ast = require('lua.st')
var operator = require('lua.operator')
var reserved = require('lua.reserved')
var scoping = require('lua.scope')
var scope
var Keyword = reserved.Keyword
var LJ_52 = false

var EndOfChunk = { TK_dedent = true, TK_else = true, TK_until = true, TK_eof = true }
var EndOfFunction = { ['}'] = true, [')'] = true, [';'] = true, [','] = true} -- `,` is to end function within a table
var NewLine = { TK_newline = true }
-- expr kind
var Kind = { Expr = 1, Var = 3, Field = 4, Index = 5, Call = 6 }

-- disallow multiple statement on one line
-- need to be in file scope coz parse_chunk() is recursive
var stmted  -- keep the line number that we parsed

var is_keyword = \ls ->
	var str = ls.tostr(ls.token)
	if Keyword[str]
		return str

var err_warn = \ls, em ->
	ls.error(ls, 2, "%s", em)


var err_syntax = \ls, em ->
	ls.error(ls, 10, "%s", em)


var as_val = \ls ->
	if ls.value
		return "'" .. ls.value .. "'"


var err_instead = \ls, severe, em, ... ->
	var msg = string.format(em, ...)
	ls.error(ls, severe, "%s instead of %s", msg, as_val(ls) or ls.astext(ls.token))


var err_expect = \ls, token ->
	err_instead(ls, 10, "%s expected", ls.astext(token))


var err_symbol = \ls ->
	var sym = ls.tostr(ls.token)
	var replace = {end = "<dedent>", local = "`var`", function = "\\...->", elseif = "`else if`", repeat = "`do`"}
	var rep = replace[sym]
	if rep
		ls.error(ls, 7, "use %s instead of '%s'", rep, sym)
	else
		ls.error(ls, 10, "unexpected %s", as_val(ls) or ls.astext(ls.token))


var lex_opt = \ls, tok ->
	if ls.token == tok
		ls.step()
		return true
	return false


var lex_check = \ls, tok ->
	if ls.token ~= tok
		err_expect(ls, tok) 
	ls.step()


var lex_match = \ls, what, who, line ->
	if not lex_opt(ls, what)
		if line == ls.line
			err_expect(ls, what)
		else
			err_instead(ls, 10, "%s expected to match %s at line %d", ls.astext(what), ls.astext(who), line)


var lex_str = \ls ->
	var s
	if ls.token ~= 'TK_name' and (LJ_52 or ls.token ~= 'TK_goto')
		err_expect(ls, 'TK_name')
		-- no longer exiting, so cannot be nil
		s = ls.tostr(ls.token)
	else
		s = ls.value
	ls.step()
	return s


-- return true only if a real indent is eaten
var lex_indent = \ls ->
	if NewLine[ls.token] and ls.next() == 'TK_indent'
		lex_opt(ls, 'TK_newline')
		ls.step()
		return true
	return false


-- return true only if a real dedent is eaten
var lex_dedent = \ls ->
	if ls.token == 'TK_dedent' or NewLine[ls.token] and ls.next() == 'TK_dedent'
		lex_opt(ls, 'TK_newline')
		ls.step()
		return true
	return false


var lex_opt_dent = \ls, dented ->
	if not dented
		dented = lex_indent(ls)
	else
		dented = not lex_dedent(ls)
	lex_opt(ls, 'TK_newline')
	return dented


var declare_var = \ls, name, vtype ->
	if name == '@'
		name = 'self'
	scope.declare(name, vtype, ls.line)
	return name


--- Expressions ------------------------------------------------
var expr_primary, expr, expr_unop, expr_binop, expr_simple, expr_list, expr_table
var parse_body, parse_args, parse_block, parse_opt_chunk

var var_name = \ls ->
	var name = lex_str(ls)
	var vk = Kind.Var
	if name == '@'
		name = 'self'
	if scope.declared(name) == 0
		err_warn(ls, "undeclared identifier `" .. name .. "`")
	return ast.identifier(name), vk


var expr_field = \ls, v ->
	ls.step() -- Skip dot or colon.
	var key = is_keyword(ls)
	if key
		ls.step()
		return ast.expr_index(v, ast.literal(key))

	key = lex_str(ls)
	return ast.expr_property(v, key), v, key


var expr_bracket = \fn, ls ->
	ls.step() -- Skip '['.
	var v = expr(fn, ls)
	lex_check(ls, ']')
	return v


expr_table = \fn, ls ->
	var line = ls.line
	var kvs = {}
	var dented = false
	lex_check(ls, '{')
	while ls.token ~= '}'
		dented = lex_opt_dent(ls, dented)
		-- catch common mistake that mess everything later
		if not dented and ls.token == 'TK_dedent'
			err_symbol(ls)
			ls.step()

		-- in case the table ends immediately
		if ls.token == '}'
			break
		var key
		if ls.token == '['
			key = expr_bracket(fn, ls)
			lex_check(ls, '=')
		else if ls.next() == '='
			if ls.token == 'TK_name' -- or (not LJ_52 and ls.token == 'TK_goto')    `goto` can be table key
				var name = lex_str(ls)
				key = ast.literal(name)
			else if ls.token == 'TK_string'
				key = ast.literal(ls.value)
				ls.step()
			else
				var name = is_keyword(ls)
				if name
					key = ast.literal(name)
					ls.step()
			lex_check(ls, '=')
	
		var val = expr(fn, ls)
		if key
			for i = 1, #kvs
				var arr = kvs[i]
				if ast.same(arr[2], key)
					err_warn(ls, "duplicate key at position " .. i .. " and " .. (#kvs + 1) .. " in table")
	
		kvs[#kvs + 1] = { val, key }  -- key can be nil

		dented = lex_opt_dent(ls, dented)
		if ls.token == ';'
			err_instead(ls, 3, "use %s", ls.astext(','))
		if not lex_opt(ls, ',') and not lex_opt(ls, ';')
			break

	if dented and not lex_dedent(ls)
		err_instead(ls, 10, "%s expected to match %s at line %d", ls.astext('TK_dedent'), ls.astext('TK_indent'), line)
	lex_match(ls, '}', '{', line)
	return ast.expr_table(kvs, line)


var expr_function = \fn, ls ->
	var line = ls.line
	if ls.token == '\\'
		ls.step()
	var curry, args, body, varargs = parse_body(fn, ls, line)
	var lambda = ast.expr_function(args, body, varargs)
	if curry
		if scope.declared('curry') == 0
			err_warn(ls, "require('lib.curry') is needed to use `~>`")
		
		var cargs = { ast.literal(#args), lambda }
		return ast.expr_function_call(ast.identifier('curry'), cargs, line)

	return lambda
  

expr_simple = \fn, ls ->
	var tk, val = ls.token, ls.value
	var e
	if tk == 'TK_number'
		e = ast.numberliteral(val)
	else if tk == 'TK_string'
		e = ast.literal(val)
	else if tk == 'TK_longstring'
		e = ast.longstrliteral(val)
	else if tk == 'TK_nil'
		e = ast.literal(nil)
	else if tk == 'TK_true'
		e = ast.literal(true)
	else if tk == 'TK_false'
		e = ast.literal(false)
	else if tk == '...'
		if not fn.varargs
			err_syntax(ls, "cannot use `...` in a function without variable arguments")
		e = ast.expr_vararg()
	else if tk == '{'
		return expr_table(fn, ls)
	else if tk == '\\' or tk == '->' or tk == '~>'
		return expr_function(fn, ls)
	else
		return expr_primary(fn, ls)

	ls.step()
	return e


-- nmax checks the max number of expression expected
expr_list = \fn, ls, nmax ->
	var exps = {}
	exps[1] = expr(fn, ls)
	
	while ls.token == ','
		ls.step()
		exps[#exps + 1] = expr(fn, ls)

	var n = #exps
	if nmax and n > nmax
		err_warn(ls, "assigning " .. n .. " values to " .. nmax .. " variable(s)")
	--if n > 0
	--	exps[n] = ast.set_expr_last(exps[n])
	return exps


expr_unop = \fn, ls ->
	var tk = ls.token
	if tk == 'TK_not' or tk == '-' or tk == '#'
		var line = ls.line
		ls.step()
		var v = expr_binop(fn, ls, operator.unary_priority)
		return ast.expr_unop(ls.tostr(tk), v, line)
	else
		return expr_simple(fn, ls)


-- Parse binary expressions with priority higher than the limit.
expr_binop = \fn, ls, limit ->
	var v = expr_unop(fn, ls)
	var op = ls.tostr(ls.token)
	while operator.is_binop(op) and operator.left_priority(op) > limit
		var line = ls.line
		ls.step()
		var v2, nextop = expr_binop(fn, ls, operator.right_priority(op))
		v = ast.expr_binop(op, v, v2, line)
		op = nextop

	return v, op


expr = \fn, ls ->
	return expr_binop(fn, ls, 0) -- Priority 0: parse whole expression.


-- Parse primary and prefix expression
expr_primary = \fn, ls ->
	var v, vk
	if ls.token == '('
		var line = ls.line
		ls.step()
		vk, v = Kind.Expr, ast.expr_brackets(expr(fn, ls))
		lex_match(ls, ')', '(', line)
	else --if ls.token == 'TK_name' or (not LJ_52 and ls.token == 'TK_goto')    -- comment out coz err_symbol() will not quit, and v will be nil
		v, vk = var_name(ls)
	--else
	--	err_symbol(ls)

	var val, key
	while true -- Parse multiple expression suffixes
		var line = ls.line
		if ls.token == '.'
			vk, v, val, key = Kind.Field, expr_field(ls, v)
		else if ls.token == '['
			key = expr_bracket(fn, ls)
			val = v
			vk, v = Kind.Index, ast.expr_index(val, key)
		else if ls.token == '(' -- or ls.token == 'TK_string' or ls.token == '{'
			var args, self1 = parse_args(fn, ls)
			if self1 and (vk == Kind.Field or vk == Kind.Index)
				if vk == Kind.Field
					vk, v = Kind.Call, ast.expr_method_call(val, key, args, line)
				else if vk == Kind.Index
					-- simulate a wrapped self method call
					var nm = '_0'   -- lets hope we dont name clash
					var obj = ast.identifier(nm)
					table.insert(args, 1, obj)
					var body = {
						ast.local_decl({obj}, {val}, line)
						, ast.return_stmt({
							ast.expr_function_call(ast.expr_index(obj, key), args, line)
						}, line)
					}
					var lambda = ast.expr_function({}, body, false)
					vk, v = Kind.Call, ast.expr_function_call(lambda, {}, line)
			else
				vk, v = Kind.Call, ast.expr_function_call(v, args, line)
		else
			break

	return v, vk


--- Statements ------------------------------------------------

var parse_return = \fn, ls, line ->
	ls.step() -- skip 'return'
	ast.has_return = true
	var exps
	if EndOfChunk[ls.token] or NewLine[ls.token] or EndOfFunction[ls.token]  -- or ls.token == ';'
		exps = {}
	else -- return with one or more values
		exps = expr_list(fn, ls)
	return ast.return_stmt(exps, line)


-- Parse numeric 'for'
var parse_for_num = \fn, ls, varname, line ->
	lex_check(ls, '=')
	var init = expr(fn, ls)
	lex_check(ls, ',')
	var last = expr(fn, ls)
	var step
	if lex_opt(ls, ',')
		step = expr(fn, ls)
	else
		step = ast.literal(1)
	
	scope.enter_block(fn)  -- scope for visible var
	var name = declare_var(ls, varname, nil)
	var v = ast.identifier(name)
	
	var body = parse_block(fn, ls, line, 'TK_for')
	scope.leave_block(fn)
	return ast.for_stmt(v, init, last, step, body, line, ls.line)


-- Parse 'for' iterator
var parse_for_iter = \fn, ls, indexname ->
	scope.enter_block(fn)  -- scope for visible var
	var name = declare_var(ls, indexname, nil)
	var vars = { ast.identifier(name) }	
	while lex_opt(ls, ',')
		name = lex_str(ls)
		name = declare_var(ls, name, nil)
		vars[#vars + 1] = ast.identifier(name)

	lex_check(ls, 'TK_in')
	var line = ls.line
	var exps = expr_list(fn, ls)
	var body = parse_block(fn, ls, line, 'TK_for')
	scope.leave_block(fn)
	return ast.for_iter_stmt(vars, exps, body, line, ls.line)


-- Parse 'for' statement
var parse_for = \fn, ls, line ->
	ls.step()  -- Skip 'for'.
	scope.enter_block(fn, true)
	var varname = lex_str(ls)  -- Get first variable name.
	var stmt
	if ls.token == '='
		stmt = parse_for_num(fn, ls, varname, line)
	else if ls.token == ',' or ls.token == 'TK_in'
		stmt = parse_for_iter(fn, ls, varname)
	else
		err_instead(ls, 10, "%s expected", "`=` or `in`")
	scope.leave_block(fn)
	return stmt


-- Parse function call argument list.
parse_args = \fn, ls ->
	var line = ls.line
	lex_check(ls, '(')
	if not LJ_52 and line ~= ls.prevline
		err_warn(ls, "ambiguous syntax (function call x new statement)")

	var dented = false
	var self1 = false
	var args, n = {}, 1
	while ls.token ~= ')'
		dented = lex_opt_dent(ls, dented)
		-- catch common mistake that mess everything later
		if not dented and ls.token == 'TK_dedent'
			err_symbol(ls)
			ls.step()
		if ls.token == ')'
			break
		if n == 1 and ls.token == 'TK_name' and ls.value == '@'
			self1 = true
			ls.step()
		else
			args[#args + 1] = expr(fn, ls)
		n = n + 1
		
		dented = lex_opt_dent(ls, dented)
		if not lex_opt(ls, ',')
			break
		
	if dented and not lex_dedent(ls)
		err_instead(ls, 10, "%s expected to match %s at line %d", ls.astext('TK_dedent'), ls.astext('TK_indent'), line)
	lex_match(ls, ')', '(', line)

	return args, self1


var parse_assignment
parse_assignment = \fn, ls, vlist, v, vk ->
	var line = ls.line
	if vk ~= Kind.Var and vk ~= Kind.Field and vk ~= Kind.Index
		err_symbol(ls)

	vlist[#vlist+1] = v
	if lex_opt(ls, ',')
		var n_var, n_vk = expr_primary(fn, ls)
		return parse_assignment(fn, ls, vlist, n_var, n_vk)
	else -- Parse RHS.
		lex_check(ls, '=')
		var exps = expr_list(fn, ls, #vlist)
		return ast.assignment_expr(vlist, exps, line)



var parse_call_assign = \fn, ls ->
	var v, vk = expr_primary(fn, ls)
	if vk == Kind.Call
		return ast.new_statement_expr(v, ls.line)
	else
		var vlist = {}
		return parse_assignment(fn, ls, vlist, v, vk)


var parse_var = \fn, ls ->
	var line = ls.line
	var lhs = {}
	repeat
		var name = lex_str(ls)
		name = declare_var(ls, name, nil)
		lhs[#lhs+1] = ast.identifier(name)
	until not lex_opt(ls, ',')

	var rhs -- optional rhs
	if lex_opt(ls, '=')
		rhs = expr_list(fn, ls, #lhs)
	else
		rhs = {}
	return ast.local_decl(lhs, rhs, line)


var parse_while = \fn, ls, line ->
	ls.step() -- Skip 'while'
	var cond = expr(fn, ls)
	scope.enter_block(fn, true)  -- loop block
	var body = parse_block(fn, ls, line, 'TK_while')
	scope.leave_block(fn)
	var lastline = ls.line
	return ast.while_stmt(cond, body, line, lastline)


var parse_then = \fn, ls, tests, line ->
	ls.step()
	tests[#tests+1] = expr(fn, ls)
	if ls.token == 'TK_then'
		err_warn(ls, "`then` is not needed")
		ls.step()
	return parse_block(fn, ls, line, 'TK_if')


var parse_if = \fn, ls, line ->
	var tests, blocks = {}, {}
	blocks[#blocks+1] = parse_then(fn, ls, tests, line)
	var else_branch
	while ls.token == 'TK_else' or NewLine[ls.token] and ls.next() == 'TK_else'
		lex_opt(ls, 'TK_newline')
		ls.step()
		if ls.token == 'TK_if'
			blocks[#blocks+1] = parse_then(fn, ls, tests, line)
		else
			else_branch = parse_block(fn, ls, ls.line, 'TK_else')
			break
	return ast.if_stmt(tests, blocks, else_branch, line)


var parse_do = \fn, ls, line ->
	ls.step() -- Skip 'do'
	var body = parse_block(fn, ls, line, 'TK_do')
	var lastline = ls.line
	return ast.do_stmt(body, line, lastline)


var parse_repeat = \fn, ls, line ->
	ls.step()  -- skip repeat
	scope.enter_block(fn, true) -- loop block
	scope.enter_block(fn)       -- scope block
	var body, _, lastline = parse_opt_chunk(fn, ls, line, 'TK_repeat')
	lex_match(ls, 'TK_until', 'TK_repeat', line)
	var cond = expr(fn, ls) -- until condition
	scope.leave_block(fn)   -- finish scope after `until`
	scope.leave_block(fn)   -- finish loop block
	return ast.repeat_stmt(cond, body, line, lastline)


var parse_break = \fn, ls, line ->
	ls.step()
	return ast.break_stmt(line)


var parse_label = \fn, ls, line ->
	ls.step() -- Skip '::'
	var name = lex_str(ls)
	lex_check(ls, '::')
	scope.dec_label(fn, name, line)
	return ast.label_stmt(name, line)


var parse_goto = \fn, ls, line ->
	var name = lex_str(ls)
	scope.dec_goto(name, line)
	return ast.goto_stmt(name, line)


-- Parse a statement. Returns the statement itself and a boolean that tells if it
-- must be the last one in a chunk.
var parse_stmt
parse_stmt = \fn, ls ->
	var line = ls.line
	var stmt
	if ls.token == 'TK_if'
		stmt = parse_if(fn, ls, line)
	else if ls.token == 'TK_for'
		stmt = parse_for(fn, ls, line)
	else if ls.token == 'TK_while'
		stmt = parse_while(fn, ls, line)
	else if ls.token == 'TK_do'
		stmt = parse_do(fn, ls, line)
	else if ls.token == 'TK_repeat'
		stmt = parse_repeat(fn, ls, line)
	--else if ls.token == 'TK_function'
	--	stmt = parse_func(fn, ls, line)
	else if ls.token == '->' or ls.token == '~>'
		err_syntax(ls, "lambda must either be assigned or invoked")
	else if ls.token == 'TK_name' and ls.value == 'var'
		ls.step()
		stmt = parse_var(fn, ls, line)
	else if ls.token == 'TK_local'
		err_symbol(ls)
		ls.step()
		stmt = parse_var(fn, ls, line)
	else if ls.token == 'TK_return'
		stmt = parse_return(fn, ls, line)
		return stmt, true -- Must be last
	else if ls.token == 'TK_break'
		stmt = parse_break(fn, ls, line)
		return stmt, not LJ_52 -- Must be last in Lua 5.1
	else if ls.token == '::'
		stmt = parse_label(fn, ls, line)
	else if ls.token == 'TK_goto'
		if LJ_52 or ls.next() == 'TK_name'
			ls.step()
			stmt = parse_goto(fn, ls, line)
		-- else fall thru
		
	-- is TK_name, must be function call or assignment
	if not stmt
		stmt = parse_call_assign(fn, ls)
	return stmt, false


-- a chunk is a list of statements, regardless of scope
var parse_chunk = \fn, ls ->
	
	var skip_ends = ->
		while ls.token == ';' or ls.token == 'TK_end'
			err_symbol(ls)
			ls.step()
		lex_opt(ls, 'TK_newline')
		
	var firstline = ls.line
	var stmt, islast = nil, false
	var body = {}
	while not islast and not EndOfChunk[ls.token]
		stmted = ls.line
		skip_ends()
		stmt, islast = parse_stmt(fn, ls)
		body[#body + 1] = stmt
		skip_ends()
		-- disallow multiple statement in one line
		if stmted == ls.line
			if ls.token ~= 'TK_eof' and ls.token ~= 'TK_dedent' and ls.next() ~= 'TK_eof'
				err_instead(ls, 5, "only one statement allowed per line. %s expected", ls.astext('TK_newline'))
	return body, firstline, ls.line


-- parse indented single or list of statements, regardless of scope
parse_opt_chunk = \fn, ls, line, match_token ->
	var body = {}
	if lex_indent(ls)
		body = parse_chunk(fn, ls)
		--lex_match(ls, 'TK_dedent', match_token, line)
		if not lex_dedent(ls)
			err_instead(ls, 10, "%s expected to end %s at line %d", ls.astext('TK_dedent'), ls.astext(match_token), line)
	else
		if not EndOfChunk[ls.token] and not NewLine[ls.token] and not EndOfFunction[ls.token]
			-- single statement
			body[1] = parse_stmt(fn, ls)
			--body.firstline, body.lastline = line, ls.line

		if not EndOfChunk[ls.token] and not NewLine[ls.token] and not EndOfFunction[ls.token]
			err_instead(ls, 10, "only one statement may stay near %s. %s expected", ls.astext(match_token), ls.astext('TK_newline'))
		-- returning multiple values need ; if it stays with other expressions on the same line
		else if EndOfFunction[ls.token]
			lex_opt(ls, ';')
	return body


parse_block = \fn, ls, line, match ->
	scope.enter_block(fn)
	var chunk = parse_opt_chunk(fn, ls, line, match)
	scope.leave_block(fn)
	return chunk


-- Parse function definition parameters
var parse_params = \fn, ls ->
	var args = {}
	if ls.token ~= '->' and ls.token ~= '~>'
		repeat
			if ls.token == 'TK_name' or (not LJ_52 and ls.token == 'TK_goto')
				var name = lex_str(ls)
				name = declare_var(ls, name, nil)
				args[#args+1] = ast.identifier(name)
			else if ls.token == '...'
				ls.step()
				fn.varargs = true
				args[#args + 1] = ast.expr_vararg()
				break
			else
				err_instead(ls, 10, "parameter expected for %s", ls.astext('->'))
		until not lex_opt(ls, ',')

	if ls.token == '->'
		ls.step()
		return false, args
	else if ls.token == '~>'
		if fn.varargs
			err_syntax(ls, "cannot curry variadic parameters with `~>`")
		if #args < 2
			err_syntax(ls, "at least 2 parameters needed with `~>`")
		ls.step()
		return true, args
	err_expect(ls, '->')


-- Parse body of a function
parse_body = \fn, ls, line ->
	fn = scope.begin_func(fn)
	var curry, args = parse_params(fn, ls)
	var body = parse_opt_chunk(fn, ls, line, '->')
	fn = scope.end_func(fn)
	return curry, args, body, fn.varargs


var parse = \ls ->
	-- provide error function for scoping to call
	scope = scoping(\em -> err_warn(ls, em))

	-- main chunk is always a vararg function
	var fn = scope.begin_func(nil)
	fn.varargs = true

	ls.step()
	lex_opt(ls, 'TK_newline')
	var chunk, _, lastline = parse_chunk(fn, ls)
	fn = scope.end_func(fn)
	assert(fn == nil)
	if ls.token ~= 'TK_eof'
		err_warn(ls, "code should end. unexpected extra " .. ls.astext(ls.token))
	return ast.chunk(chunk, ls.chunkname, 0, lastline)


return parse
