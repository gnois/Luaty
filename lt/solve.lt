var ty = require('lua.type')
var Tag = require('lua.tag')
var TType = Tag.Type

return ->
	-- list of type var to type expr
	var subs = {}

	var Subst = {}
	var subst = \node, tvar, texp ->
		assert(tvar.tag == TType.New)
		var rule = Subst[node.tag]
		if rule
			return rule(node, tvar, texp)
		return node

	Subst[TType.New] = \node, tvar, texp ->
		if node.id == tvar.id
			return texp
		return node

	Subst[TType.Ref] = \node, tvar, texp ->
		if node.ins
			var ins, outs = {}, {}
			for i, p in ipairs(node.ins)
				ins[i] = subst(p, tvar, texp)
			for i, r in ipairs(node.outs)
				outs[i] = subst(r, tvar, texp)
			return ty.func(ty.tuple(ins), ty.tuple(outs))

		var tytys = {}
		for i, tk in ipairs(node)
			tytys[i] = { subst(tk[1], tvar, texp), tk[2] and subst(tk[2], tvar, texp) }
		return ty.tbl(tytys)

	Subst[TType.Or] = \node, tvar, texp ->
		var list = {}
		for i, t in ipairs(node)
			list[i] = subst(t, tvar, texp)
		return ty.or(unpack(list))




	var Apply = {}
	var apply = \node ->
		var rule = Apply[node.tag]
		if rule
			return rule(node)
		return node

	Apply[TType.New] = \node ->
		return subs[node.id] or node

	Apply[TType.Ref] = \node ->
		if node.ins
			var ins, outs = {}, {}
			for i, p in ipairs(node.ins)
				ins[i] = apply(p)
			for i, r in ipairs(node.outs)
				outs[i] = apply(r)
			return ty.func(ty.tuple(ins), ty.tuple(outs))

		var tytys = {}
		for i, tk in ipairs(node)
			tytys[i] = { apply(tk[1]), tk[2] and apply(tk[2]) }
		return ty.tbl(tytys)

	Apply[TType.Or] = \node ->
		var list = {}
		for i, t in ipairs(node)
			list[i] = apply(t)
		return ty.or(unpack(list))



	var Occur = {}
	var occurs = \x, y ->
		var rule = Occur[x.tag]
		if rule
			return rule(x, y)
		return false

	Occur[TType.Ref] = \node, y ->
		if node.ins
			for _, p in ipairs(node.ins)
				if occurs(p, y)
					return true
			for _, r in ipairs(node.outs)
				if occurs(r, y)
					return true
			return false
		
		for _, tk in ipairs(node)
			if occurs(tk[1], y) or (tk[2] and occurs(tk[2], y))
				return true
		return false

	Occur[TType.Or] = \node, y ->
		for _, t in ipairs(node)
			if occurs(t, y)
				return true
		return false



	var extend = \tvar, texp ->
		assert(tvar.tag == TType.New)
		if occurs(tvar, texp)
			return false, "cannot infer recursive type"

		for id, t in ipairs(subs)
			subs[id] = subst(t, tvar, texp)
		subs[tvar.id] = texp
		return true



	var unify

	var unify_func = \x, y ->
		var xs, ys = x.ins, y.ins
		var i, n = 0, #xs
		-- check if too few args
		var ok, err
		while i < n
			i = i + 1
			if ys[i]
				ok, err = unify(xs[i], ys[i])
				if not ok
					return false, "parameter " .. i .. " " .. err
			else
				if not xs[i].varargs
					return false, "expects " .. n .. " arguments but only got " .. (i-1)
				return true

		-- check if too many args
		n = #ys
		if i < n
			if i < 1 or not xs[i].varargs
				return false, "expects only " .. i .. " arguments but got " .. n
		--unify_tuple(y, x.outs, y.outs, false)
		return true


	-- return true if x is contained in y or y.meta
	var unify_tbl = \x, y ->

		var key_str = \k ->
			return "string" == type(k) and k or ty.tostr(k)
			
		var keys = {}
		-- convert to lookup table
		for __, tty in ipairs(y)
			if tty[2]
				keys[tty[2]] = tty[1]
				
		for _, ttx in ipairs(x)
			if ttx[2]
				var vy = keys[ttx[2]]
				if vy
					var ok, err = unify(ttx[1], vy)
					if not ok
						return false, err .. " for key `" .. key_str(ttx[2]) .. "`"
				else
					return false, "expects key `" .. key_str(ttx[2]) .. "`"

		return true

	-- return false, msg if type mismatch
	unify = \x, y ->
		-- shortcut
		if x == y
			return true
			
		x = apply(x)
		y = apply(y)

		if x.tag == TType.New
			return extend(x, y)

		if y.tag == TType.New
			return extend(y, x)

		-- any match all except pure nil
		if x.tag == TType.Any and y.tag ~= TType.Nil
			return true
			
		if y.tag == TType.Any and x.tag ~= TType.Nil
			return true

		if x.tag == TType.Or
			for _, t in ipairs(x)
				if unify(t, y)
					return true

		if y.tag == TType.Or
			for _, t in ipairs(y)
				if unify(x, t)
					return true


		if x.tag == y.tag
			if x.tag == TType.Nil
				return true

			if x.tag == TType.Val
				if x.type == y.type
					return true
					
			if x.tag == TType.Ref
				if x.ins and y.ins
					return unify_func(x, y)
				
				return unify_tbl(x, y)

		return false, "expects " .. ty.tostr(x) .. " instead of " .. ty.tostr(y)


	return {
		apply = apply
		, unify = unify
	}
