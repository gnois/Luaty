var ty = require('lt.type')
var Tag = require('lt.tag')
var TType = Tag.Type

return ->
	-- list of type var to type expr
	var subs = {}

	------ subst --------------
	var Subst = {}
	var subst = \node, tvar, texp ->
		assert(tvar.tag == TType.New)
		var rule = Subst[node.tag]
		if rule
			return rule(node, tvar, texp)
		return node

	Subst[TType.New] = \node, tvar, texp ->
		if node.id == tvar.id
			return texp
		return node

	Subst[TType.Func] = \node, tvar, texp ->
		var ins, outs = {}, {}
		for i, p in ipairs(node.ins)
			ins[i] = subst(p, tvar, texp)
		for i, r in ipairs(node.outs)
			outs[i] = subst(r, tvar, texp)
		return ty.func(ty.tuple(ins), ty.tuple(outs))

	Subst[TType.Tbl] = \node, tvar, texp ->
		var tytys = {}
		for i, tk in ipairs(node)
			tytys[i] = { subst(tk[1], tvar, texp), tk[2] and subst(tk[2], tvar, texp) }
		return ty.tbl(tytys)

	Subst[TType.Or] = \node, tvar, texp ->
		var list = {}
		for i, t in ipairs(node)
			list[i] = subst(t, tvar, texp)
		return ty.or(unpack(list))


	------ apply --------------
	var Apply = {}
	var apply = \node ->
		var rule = Apply[node.tag]
		if rule
			return rule(node)
		return node

	Apply[TType.New] = \node ->
		return subs[node.id] or node

	Apply[TType.Func] = \node ->
		var ins, outs = {}, {}
		for i, p in ipairs(node.ins)
			ins[i] = apply(p)
		for i, r in ipairs(node.outs)
			outs[i] = apply(r)
		return ty.func(ty.tuple(ins), ty.tuple(outs))

	Apply[TType.Tbl] = \node ->
		var tytys = {}
		for i, tk in ipairs(node)
			tytys[i] = { apply(tk[1]), tk[2] and apply(tk[2]) }
		return ty.tbl(tytys)

	Apply[TType.Or] = \node ->
		var list = {}
		for i, t in ipairs(node)
			list[i] = apply(t)
		return ty.or(unpack(list))


	------ occur --------------
	var Occur = {}
	var occurs = \x, y ->
		var rule = Occur[y.tag]
		if rule
			return rule(x, y)
		return false

	Occur[TType.New] = \x, node ->
		return x.id == node.id

	Occur[TType.Func] = \x, node ->
		for _, p in ipairs(node.ins)
			if occurs(x, p)
				return true
		for _, r in ipairs(node.outs)
			if occurs(x, r)
				return true
		return false

	Occur[TType.Tbl] = \x, node ->
		for _, tk in ipairs(node)
			if occurs(x, tk[1]) or (tk[2] and occurs(x, tk[2]))
				return true
		return false

	Occur[TType.Or] = \x, node ->
		for _, t in ipairs(node)
			if occurs(x, t)
				return true
		return false


	var extend = \tvar, texp, ignore ->
		assert(tvar.tag == TType.New)
		if occurs(tvar, texp)
			return false, ignore and "" or ("contains recursive type " .. ty.tostr(tvar) .. " in " .. ty.tostr(texp))

		for id, t in ipairs(subs)
			subs[id] = subst(t, tvar, texp)
		subs[tvar.id] = texp
		return tvar


	------ unification --------------
	var unify

	var unify_func = \x, y, ignore ->
		var xs, ys = x.ins, y.ins
		var i, n = 0, #xs
		-- check if too few args
		var t, err
		while i < n
			i = i + 1
			if ys[i]
				t, err = unify(xs[i], ys[i], ignore)
				if not t
					return false, ignore and "" or ("parameter " .. i .. " " .. err)
			else
				if not xs[i].varargs
					return false, ignore and "" or ("expects " .. n .. " arguments but only got " .. (i-1))
				return true

		-- check if too many args
		n = #ys
		if i < n
			if i < 1 or not xs[i].varargs
				return false, ignore and "" or ("expects only " .. i .. " arguments but got " .. n)

		-- check return types
		xs, ys = x.outs, y.outs
		i, n = 0, #xs
		while i < n
			i = i + 1
			t, err = unify(xs[i], ys[i] or ty.nil(), ignore)
			if not t
				return false, ignore and "" or ("return value " .. i .. " " .. err)
		-- ignore extra returns
		return true


	-- return true if x is contained in y
	var unify_tbl = \x, y, ignore ->
		var key_str = \k ->
			return "string" == type(k) and k or ty.tostr(k)
			
		var keys = {}
		-- convert to lookup table
		for __, tty in ipairs(y)
			if tty[2]
				keys[tty[2]] = tty[1]
				
		for _, ttx in ipairs(x)
			if ttx[2]
				var vy = keys[ttx[2]]
				if vy
					var ok, err = unify(ttx[1], vy, ignore)
					if not ok
						return false, err
				else
					return nil, ignore and "" or ("expects key `" .. key_str(ttx[2]) .. "` in " .. ty.tostr(y))

		return true


	-- return false, msg if type mismatch
	unify = \x, y, ignore ->
		-- shortcut
		if x == y
			return true
		x = apply(x)
		y = apply(y)

		if x.tag == TType.New
			return extend(x, y)

		if y.tag == TType.New
			return extend(y, x)

		-- any match all except pure nil
		if x.tag == TType.Any and y.tag ~= TType.Nil
			return true
			
		if y.tag == TType.Any and x.tag ~= TType.Nil
			return true

		if x.tag == TType.Or
			for _, t in ipairs(x)
				var tt, err = unify(t, y, ignore)
				if tt == nil or tt
					return tt, err

		if y.tag == TType.Or
			for _, t in ipairs(y)
				var tt, err = unify(x, t, ignore)
				if tt == nil or tt
					return tt, err

		if x.tag == y.tag
			if x.tag == TType.Nil
				return true

			if x.tag == TType.Val
				if x.type == y.type
					return true

			if x.tag == TType.Func
				return unify_func(x, y, ignore)

			if x.tag == TType.Tbl
				return unify_tbl(x, y, ignore)

		return false, ignore and "" or ("expects " .. ty.tostr(x) .. " instead of " .. ty.tostr(y))


	return {
		apply = apply
		, extend = extend
		, unify = unify
	}
