var ast = require('lua.ast')
var Tag = require('lua.tag')
var TType = Tag.Type

return \warn ->
	-- type var map
	var subs = {}

	var err = \t, msg ->
		warn(t.line, t.col, 1, msg)

	var Subst = {}
	var subst = \node, tvar, texp ->
		assert(tvar.tag == TType.New)
		var rule = Subst[node.tag]
		if rule
			return rule(node, tvar, texp)
		return node

	Subst[TType.New] = \node, tvar, texp ->
		if node.id == tvar.id
			return texp
		return node

	Subst[TType.Ref] = \node, tvar, texp ->
		if node.params
			var params, returns = {}, {}
			for i, p in ipairs(node.params.types)
				params[i] = subst(p, tvar, texp)
			for i, r in ipairs(node.returns.types)
				returns[i] = subst(r, tvar, texp)
			return ast.Type.func(ast.Type.tuple(params, node), ast.Type.tuple(returns, node), node)

		var tytys = {}
		for i, tk in ipairs(node.tytys)
			tytys[i] = { subst(tk[1], tvar, texp), tk[2] and subst(tk[2], tvar, texp) }
		return ast.Type.tbl(tytys, node)

	Subst[TType.Or] = \node, tvar, texp ->
		var left = subst(node.left, tvar, texp)
		var right = subst(node.right, tvar, texp)
		return ast.Type.or(left, right, node)

	Subst[TType.And] = \node, tvar, texp ->
		var left = subst(node.left, tvar, texp)
		var right = subst(node.right, tvar, texp)
		return ast.Type.and(left, right, node)



	var Apply = {}
	var apply = \ty ->
		var rule = Apply[ty.tag]
		if rule
			return rule(ty)
		return ty

	Apply[TType.New] = \node ->
		return subs[node.id] or node

	Apply[TType.Ref] = \node ->
		if node.params
			var params, returns = {}, {}
			for i, p in ipairs(node.params.types)
				params[i] = apply(p)
			for i, r in ipairs(node.returns.types)
				returns[i] = apply(r)
			return ast.Type.func(ast.Type.tuple(params, node), ast.Type.tuple(returns, node), node)

		var tytys = {}
		for i, tk in ipairs(node.tytys)
			tytys[i] = { apply(tk[1]), tk[2] and apply(tk[2]) }
		return ast.Type.tbl(tytys, node)

	Apply[TType.Or] = \node ->
		var left = apply(node.left)
		var right = apply(node.right)
		return ast.Type.or(left, right, node)

	Apply[TType.And] = \node ->
		var left = apply(node.left)
		var right = apply(node.right)
		return ast.Type.and(left, right, node)


	var Occur = {}
	var occurs = \tx, ty ->
		var rule = Occur[tx.tag]
		if rule
			return rule(tx, ty)
		return false

	Occur[TType.Ref] = \node, ty ->
		if node.params
			for _, p in ipairs(node.params.types)
				if occurs(p, ty)
					return true
			for _, r in ipairs(node.returns.types)
				if occurs(r, ty)
					return true
			return false

		for _, tk in ipairs(node.tytys)
			if occurs(tk[1], ty) or (tk[2] and occurs(tk[2], ty))
				return true
		return false

	Occur[TType.Or] = \node, ty ->
		return occurs(node.left, ty) or occurs(node.right, ty)

	Occur[TType.And] = \node, ty ->
		return occurs(node.left, ty) or occurs(node.right, ty)


	-- a substitution is a map of {id: texp}
	var extend = \tvar, texp ->
		assert(tvar.tag == TType.New)
		if occurs(tvar, texp)
			err(tvar, "cannot infer recursive type")
			return subs
		for id, t in ipairs(subs)
			subs[id] = subst(t, tvar, texp)
		subs[tvar.id] = texp



	var unify

	var unify_func = \tx, ty ->
		var xs, ys = tx.params.types, ty.params.types
		var i, n = 0, #xs
		-- check if too few args
		while i < n
			i = i + 1
			if ys[i]
				unify(xs[i], ys[i])
			else
				if not unify(xs[i], ast.Type.nil(xs[i]))
					err(ty, "too few arguments: taking " .. n .. " but only " .. (i-1) .. " given")

		-- check if too few args
		n = #ys
		if i < n
			if i < 1 or not xs[i].varargs
				err(ty, "too many arguments: taking " .. i .. " but only " .. n .. " given")
		--unify_tuple(ty, tx.returns, ty.returns, false)


	var unify_tbl = \tx, ty ->
	--``
		var keys, k = {}, 0
		for _, tkx in ipairs(tx.tytys)
			for __, tky in ipairs(ty.tytys)
				if tkx[2] == tky[2]
					k = k + 1
					keys[k] = tkx[2]
					unify(tkx[1], tky[1])
		
		-- for keys that didnt match, check if they are nillable
		for _, key in ipairs(keys)
			for __, tk in ipairs(tx.tytys)
				if tk[2] and tk[2] ~= key
					var tkey2 = ast.Type.new(tk[1])
					ast.nils(tkey2)
					unify(tk[1], tkey2)
			
			for __, tk in ipairs(ty.tytys)
				if tk[2] and tk[2] ~= key
					var key2 = ast.Type.new(tk[1])
					ast.nils(key2)
					unify(tk[1], key2)
	``


	unify = \tx, ty ->
		tx = apply(tx)
		ty = apply(ty)

		if tx.tag == TType.New
			extend(tx, ty)
			return
			
		if ty.tag == TType.New
			extend(ty, tx)
			return
			
		if tx.tag == TType.Any
			-- if nillable, match everything. Else match all except pure nil
			if tx.nil or ty.tag ~= TType.nil
				return
			
		if ty.tag == TType.Any
			if ty.nil or tx.tag ~= TType.nil
				return
		
		if tx.nil and ty.tag == TType.nil
			return
		
		if ty.nil and tx.tag == TType.nil
			return

		if tx.tag == ty.tag
			if tx.tag == TType.nil
				return

			if tx.tag == TType.Val
				if tx.type == ty.type
					return
					
			if tx.tag == TType.Ref
				if tx.params and ty.params
					unify_func(tx, ty)
					return
				
				if tx.tytys and ty.tytys
					unify_tbl(tx, ty)
					return

		err(ty, "type mismatch: " .. ast.tostr(tx) .. " expected, got " .. ast.tostr(ty))


	return {
		apply = apply
		, unify = unify
	}
