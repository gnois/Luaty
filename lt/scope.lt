var builtins = {
	assert = true
	, collectgarbage = true
	, coroutine = true
	, debug = true
	, dofile = true
	, error = true
	, _G = true
	, getfenv = true
	, getmetatable = true
	, io = true
	, ipairs = true
	, load = true
	, loadfile = true
	, loadstring = true
	, math = true
	, next = true
	, os = true
	, package = true
	, pairs = true
	, pcall = true
	, print = true
	, rawequal = true
	, rawget = true
	, rawlen = true
	, rawset = true
	, select = true
	, setfenv = true
	, setmetatable = true
	, string = true
	, table = true
	, tonumber = true
	, tostring = true
	, type = true
	, unpack = true
	, _VERSION = true
	, xpcall = true
	, module = true
	, require = true
	-- LuaJIT
	, jit = true
}


-- variable stacks during parse
var vstack = {}
var vtop = 0

var enter_block = \f, isloop ->
	f.block = {
		prev = f.block    -- link to outer scope
		, vstart = vtop   -- points to the vstack index when entering block
		, isloop = isloop -- scope is a (breakable) loop
	}

var leave_block = \f ->
	-- pop the vstack
	vtop = f.block.vstart
	assert(vtop >= 0)
	f.block = f.block.prev


-- pf is enclosing function
var begin_func = \pf ->
	var f = { parent = pf }
	enter_block(f, false)
	return f


var end_func = \f ->
	leave_block(f)
	return f.parent



var declare = \name, type ->
	vtop = vtop + 1
	vstack[vtop] = { name = name, type = type }
	return vtop


var declared = \name ->
	if builtins[name]
		return -1
	for i = vtop, 1, -1
		if vstack[i].name == name
			return 1
	return 0



return {

	enter_block = enter_block
	, leave_block = leave_block
	
	, begin_func = begin_func
	, end_func = end_func

	, declare = declare
	, declared = declared
}

