var reserved = require('lua.reserved')
var Builtin = reserved.Builtin

var unused = {
	_ = true
	, __ = true
	, ___ = true
}


return \decls, warn ->

	-- variable stacks during parse
	var vstack, vtop = {}, 0
	-- block pointer during parse
	var bptr = nil

	var declared = \name ->
		for i = vtop, 1, -1
			var v = vstack[i]
			if v.name == name
				v.used = true
				return v.line, v.type
		if Builtin[name]
			return -1
		if decls and decls[name]
			return -1
		return 0

	-- reports shadowing variable
	var new_var = \name, vtype, line, col ->
		assert(type(name) == 'string')
		assert(type(line) == 'number')
		assert(type(col) == 'number')
		var ln = declared(name)
		if ln ~= 0
			var which = "previous"
			if ln == -1
				which = "global"
			var msg = "shadowing " .. which .. " variable `" .. name .. "`"
			if ln > 0
				msg = msg .. " declared on line " .. ln
			warn(line, col, 3, msg)
		vtop = vtop + 1
		vstack[vtop] = { name = name, type = vtype, used = false, line = line, col = col }
		return vtop

	-- Note: loop block tags must be spelled correctly
	var new_break = \line, col ->
		assert(type(line) == 'number')
		assert(type(col) == 'number')
		-- report if not in loop
		var blk = bptr
		while blk.tag ~= 'Function'
			if ({While = true, Repeat = true, ForIn = true, ForNum = true})[blk.tag]
				return
			blk = blk.outer
		warn(line, col, 10, "`break` must be inside a loop")


	-- goto and label
	var new_label = \name, line, col ->
		assert(type(name) == 'string')
		assert(type(line) == 'number')
		assert(type(col) == 'number')
		if not bptr.golas
			bptr.golas = {}
		
		-- report duplicate label in all scopes
		var blk = bptr
		while blk
			if blk.golas
				for _, gl in ipairs(blk.golas)
					if gl.label == name
						warn(line, col, 4, "duplicate label ::" .. name .. ":: on line " .. gl.line)
						break
			blk = blk.outer

		table.insert(bptr.golas, { label = name, used = false, line = line, col = col, vtop = vtop })


	var new_goto = \name, line, col ->
		assert(type(name) == 'string')
		assert(type(line) == 'number')
		assert(type(col) == 'number')
		if not bptr.golas
			bptr.golas = {}
		table.insert(bptr.golas, { go = name, match = false, line = line, col = col, vtop = vtop })


	var enter_block = \tag ->
		--assert(tag) -- enforce later
		var newb = {
			tag = tag
			, vstart = vtop + 1   -- current stack pointer
			, outer = bptr        -- point to outer block
			, blocks = nil        -- child blocks in this block
			, golas = nil         -- list of gotos and labels
		}
		
		-- add to outer
		if bptr
			if not bptr.blocks
				bptr.blocks = {}
			table.insert(bptr.blocks, newb)
		bptr = newb

	var leave_block = ->
		-- report unused variables
		for n = bptr.vstart, vtop
			var v = vstack[n]
			if not v.used
				if not unused[v.name]
					warn(v.line, v.col, 3, "unused variable `" .. v.name .. "`")
	
		
		-- recursive check inner scope goto with this label
		var test_goto
		test_goto = \blocks, lbl ->
			if blocks
				for _, b in ipairs(blocks)
					test_goto(b.blocks, lbl)
					
					if b.golas
						for __, g in ipairs(b.golas)
							if lbl.label == g.go
								if lbl.vtop >= b.vstart -- start of block
									warn(g.line, g.col, 9, "goto <" .. g.go .. "> jumps into the scope of variable '" .. vstack[lbl.vtop].name .. "' at line " .. vstack[lbl.vtop].line)
								lbl.used = true
								g.match = true

		-- check goto label in this scope
		var golas = bptr.golas
		if golas
			for _, g in ipairs(golas)
				if g.go
					-- look for its label
					for __, lbl in ipairs(golas)
						if lbl.label == g.go
							if lbl.vtop > g.vtop
								warn(g.line, g.col, 9, "goto <" .. g.go .. "> jumps over the variable '" .. vstack[lbl.vtop].name .. "' declared at line " .. vstack[lbl.vtop].line)
							lbl.used = true
							g.match = true

			-- check inner blocks gotos with each label in this scope
			for _, gl in ipairs(golas)
				if gl.label
					test_goto(bptr.blocks, gl)

			-- report unused labels
			for _, gl in ipairs(golas)
				if gl.label and not gl.used
					warn(gl.line, gl.col, 3, "unused label ::" .. gl.label .. "::")

		-- pop the vstack
		vtop = bptr.vstart - 1
		assert(vtop >= 0)
		bptr = bptr.outer


	var varargs = ->
		assert(bptr)
		assert(bptr.tag == 'Function')
		bptr.varargs = true

	
	var is_varargs = ->
		var blk = bptr
		while blk.tag ~= 'Function'
			blk = blk.outer
		return blk.varargs


	-- functions are blocks
	var begin_func = ->
		enter_block('Function')


	-- function block is thrown away when leaving scope
	var end_func = ->
		
		var this = bptr
		leave_block()
		
		-- report unmatched gotos
		var unused_goto
		unused_goto = \block ->
			if block.golas
				for __, gl in ipairs(block.golas)
					if gl.go and not gl.match
						warn(gl.line, gl.col, 12, "no visible label for goto <" .. gl.go .. ">")

			if block.blocks
				for _, b in ipairs(block.blocks)
					unused_goto(b)

		unused_goto(this)
		


	return {
		begin_func = begin_func
		, end_func = end_func
		, enter_block = enter_block
		, leave_block = leave_block
		
		, varargs = varargs
		, is_varargs = is_varargs
	
		, declared = declared
		, new_var = new_var
		, new_goto = new_goto
		, new_label = new_label
		, new_break = new_break
	}
