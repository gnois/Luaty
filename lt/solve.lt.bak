var ty = require('lt.type')
var Tag = require('lt.tag')
var TType = Tag.Type

return ->
	-- list of type var to type expr
	var subs = {}

	------ subst --------------
	var Subst = {}
	var subst = \node, tvar, texp ->
		assert(tvar.tag == TType.New)
		var rule = Subst[node.tag]
		if rule
			return rule(node, tvar, texp)
		return node

	Subst[TType.New] = \node, tvar, texp ->
		if node.id == tvar.id
			return texp
		return node

	Subst[TType.Func] = \node, tvar, texp ->
		var ins, outs = {}, {}
		for i, p in ipairs(node.ins)
			ins[i] = subst(p, tvar, texp)
		for i, r in ipairs(node.outs)
			outs[i] = subst(r, tvar, texp)
		return ty.func(ty.tuple(ins), ty.tuple(outs))

	Subst[TType.Tbl] = \node, tvar, texp ->
		var tytys = {}
		for i, tk in ipairs(node)
			tytys[i] = { subst(tk[1], tvar, texp), tk[2] and subst(tk[2], tvar, texp) }
		return ty.tbl(tytys)

	Subst[TType.Or] = \node, tvar, texp ->
		var list = {}
		for i, t in ipairs(node)
			list[i] = subst(t, tvar, texp)
		return ty.or(unpack(list))


	------ apply --------------
	var Apply = {}
	var apply = \node ->
		var rule = Apply[node.tag]
		if rule
			return rule(node)
		return node

	Apply[TType.New] = \node ->
		return subs[node.id] or node

	Apply[TType.Func] = \node ->
		var ins, outs = {}, {}
		for i, p in ipairs(node.ins)
			ins[i] = apply(p)
		for i, r in ipairs(node.outs)
			outs[i] = apply(r)
		return ty.func(ty.tuple(ins), ty.tuple(outs))

	Apply[TType.Tbl] = \node ->
		var tytys = {}
		for i, tk in ipairs(node)
			tytys[i] = { apply(tk[1]), tk[2] and apply(tk[2]) }
		return ty.tbl(tytys)

	Apply[TType.Or] = \node ->
		var list = {}
		for i, t in ipairs(node)
			list[i] = apply(t)
		return ty.or(unpack(list))


	------ occur --------------
	var Occur = {}
	var occurs = \x, y ->
		var rule = Occur[y.tag]
		if rule
			return rule(x, y)
		return false

	Occur[TType.New] = \x, node ->
		return x.id == node.id

	Occur[TType.Func] = \x, node ->
		for _, p in ipairs(node.ins)
			if occurs(x, p)
				return true
		for _, r in ipairs(node.outs)
			if occurs(x, r)
				return true
		return false

	Occur[TType.Tbl] = \x, node ->
		for _, tk in ipairs(node)
			if occurs(x, tk[1]) or (tk[2] and occurs(x, tk[2]))
				return true
		return false

	Occur[TType.Or] = \x, node ->
		for _, t in ipairs(node)
			if occurs(x, t)
				return true
		return false


	var extend = \tvar, texp ->
		assert(tvar.tag == TType.New)
		if occurs(tvar, texp)
			return false, ty.tostr(texp) .. " contains recursive type " .. ty.tostr(tvar)

		for id, t in ipairs(subs)
			subs[id] = subst(t, tvar, texp)
		subs[tvar.id] = texp
		return true


	------ unification --------------
	var unify

	var unify_func = \x, y ->
		var xs, ys = x.ins, y.ins
		var i, n = 0, #xs
		-- check if too few args
		var ok, err
		while i < n
			i = i + 1
			if ys[i]
				ok, err = unify(xs[i], ys[i])
				if not ok
					return false, "parameter " .. i .. " " .. err
			else
				if not xs[i].varargs
					return false, "expects " .. n .. " arguments but only got " .. (i-1)
				return true

		-- check if too many args
		n = #ys
		if i < n
			if i < 1 or not xs[i].varargs
				return false, "expects only " .. i .. " arguments but got " .. n
		-- check return types
		xs, ys = x.outs, y.outs
		i, n = 0, #xs
		while i < n
			i = i + 1
			ok, err = unify(xs[i], ys[i] or ty.nil(), poke)
			if not ok
				return false, "return value " .. i .. " " .. err

		-- ignore extra returns
		return true


	-- return true if x is contained in y or y.meta
	var unify_tbl = \x, y ->
		var key_str = \k ->
			return "string" == type(k) and k or ty.tostr(k)
			
		var keys = {}
		-- convert to lookup table
		for __, tty in ipairs(y)
			if tty[2]
				keys[tty[2]] = tty[1]
				
		for _, ttx in ipairs(x)
			if ttx[2]
				var vy = keys[ttx[2]]
				if vy
					var ok, err = unify(ttx[1], vy)
					if not ok
						return false, err .. " for key `" .. key_str(ttx[2]) .. "`"
				else
					return false, "expects key `" .. key_str(ttx[2]) .. "` in " .. ty.tostr(y)

		return true

	-- return false, msg if type mismatch
	unify = \x, y, ignore ->
		-- shortcut
		if x == y
			return true
		x = apply(x)
		y = apply(y)

		if x.tag == TType.New
			return extend(x, y)

		if y.tag == TType.New
			return extend(y, x)

		-- any match all except pure nil
		if x.tag == TType.Any and y.tag ~= TType.Nil
			return true
			
		if y.tag == TType.Any and x.tag ~= TType.Nil
			return true

		if x.tag == TType.Or
			for _, t in ipairs(x)
				if unify(t, y, true)
					return true

		if y.tag == TType.Or
			for _, t in ipairs(y)
				if unify(x, t, true)
					return true

		if x.tag == y.tag
			if x.tag == TType.Nil
				return true

			if x.tag == TType.Val
				if x.type == y.type
					return true

			if x.tag == TType.Func
				return unify_func(x, y)

			if x.tag == TType.Tbl
				return unify_tbl(x, y)

		return false, ignore and "" or ("expects " .. ty.tostr(x) .. " instead of " .. ty.tostr(y))


	return {
		apply = apply
		, unify = unify
	}
