var Tag = require('lua.tag')

var TStmt = Tag.Stmt
var TExpr = Tag.Expr

return \stmts ->
	
	var indents = 0
	
	var indentation = ->
		return "\n"..string.rep("  ", indents)
	
	var astr = \open, close, tag, ... ->
		var list = {}
		list[1] = "`" .. tag
		for k, v in ipairs({...})
			list[1 + k] = tostring(v)
		return open .. table.concat(list, " ") .. close
		
	var expr = \tag, ... ->
		return astr('{', '}', tag, ...)
		
	var stmt = \tag, ... ->
		return astr('[', ']', tag, ...)

	var Stmt = {}
	var Expr = {}

	var visit_stmts = \nodes ->
		var list = {}
		for i, node in ipairs(nodes)
			var rule = Stmt[node.tag]
			list[i] = rule(node)
		var spaces = indentation()
		return spaces .. table.concat(list, spaces)
	
	var visit_expr = \node ->
		var rule = Expr[node.tag]
		return rule(node)
			
	var visit_exprs = \nodes ->
		var list = {}
		for i, node in ipairs(nodes)
			list[i] = visit_expr(node)
		return table.concat(list, " ")

	var block = \header, nodes ->
		indents = indents + 1
		var body = visit_stmts(nodes)
		indents = indents - 1
		return header .. body

	--------- Expressions --------------------
	Expr[TExpr.Nil] = ->
		return expr("nil")

	Expr[TExpr.Vararg] = ->
		return expr("dots")

	Expr[TExpr.Id] = \node ->
		return expr("Id", node.name)

	Expr[TExpr.Bool] = \node ->
		return expr("Bool", node.value)

	Expr[TExpr.Number] = \node ->
		return expr("Num", node.value)

	Expr[TExpr.String] = \node ->
		if node.long
			return expr("LongStr", node.value)
		return expr("Str", node.value)

	Expr[TExpr.Function] = \node ->
		return block(expr("Function", visit_exprs(node.params)), node.body)

	Expr[TExpr.Table] = \node ->
		var body = {}
		var key, val
		for i, kv in ipairs(node.keyvals)
			val = visit_expr(kv[1])
			if kv[2]
				key = visit_expr(kv[2])
				body[i] = key .. "=" .. val
			else
				body[i] = val
		return expr("Table", table.concat(body, " "))

	Expr[TExpr.Index] = \node ->
		return expr("Index", visit_expr(node.obj), visit_expr(node.idx))

	Expr[TExpr.Property] = \node ->
		return expr("Property", visit_expr(node.obj), node.prop)

	Expr[TExpr.Invoke] = \node ->
		return expr("Invoke", visit_expr(node.obj), node.prop, visit_exprs(node.args))

	Expr[TExpr.Call] = \node ->
		return expr("Call", visit_expr(node.func), visit_exprs(node.args))

	Expr[TExpr.Unary] = \node ->
		return expr("Unary", node.op, visit_expr(node.left))

	Expr[TExpr.Binary] = \node ->
		return expr("Binary", node.op, visit_expr(node.left), visit_expr(node.right))

	--------- Statements --------------------
	Stmt[TStmt.Expr] = \node ->
		return stmt("ExprStatement", visit_expr(node.expr))

	Stmt[TStmt.Local] = \node ->
		return stmt("Local", visit_exprs(node.vars), visit_exprs(node.exprs))

	Stmt[TStmt.Assign] = \node ->
		return stmt("Assign", visit_exprs(node.lefts), visit_exprs(node.rights))

	Stmt[TStmt.Do] = \node ->
		return block(stmt("Do"), node.body)

	Stmt[TStmt.If] = \node ->
		var blocks = {}
		blocks[1] = block(stmt("If", visit_expr(node.tests[1])), node.thenss[1])
		for i = 2, #node.tests, 1
			blocks[i] = block(indentation() .. "elseif " .. visit_expr(node.tests[i]), node.thenss[i])
		if node.elses
			blocks[#blocks + 1] = block(indentation() .. "else", node.elses)
		return table.concat(blocks)

	Stmt[TStmt.Forin] = \node ->
		return block(stmt("Forin", visit_exprs(node.vars), visit_exprs(node.exprs)), node.body)

	Stmt[TStmt.Fornum] = \node ->
		return block(stmt("Fornum", visit_expr(node.var), visit_expr(node.first), visit_expr(node.last), node.step and visit_expr(node.step) or ""), node.body)

	Stmt[TStmt.While] = \node ->
		return block(stmt("While", visit_expr(node.test)), node.body)

	Stmt[TStmt.Repeat] = \node ->
		return block(stmt("Repeat until", visit_expr(node.test)), node.body)

	Stmt[TStmt.Return] = \node ->
		return stmt("Return", visit_exprs(node.exprs))

	Stmt[TStmt.Break] = ->
		return stmt("Break")

	Stmt[TStmt.Goto] = \node ->
		return stmt("Goto", node.name)
		
	Stmt[TStmt.Label] = \node ->
		return stmt("Label", node.name)
	
	return visit_stmts(stmts)

