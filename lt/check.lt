var ast = require('lua.ast')
var typ = require('lua.type')
var Tag = require('lua.tag')
var TStmt = Tag.Stmt
var TExpr = Tag.Expr
var TType = Tag.Type

return \scope, stmts, warn ->

	var Stmt = {}
	var Expr = {}
	var Type = {}
	var ty = typ(warn)
	
	var fail = \node ->
		var msg = (node.tag or 'nil') .. " cannot match a statement type"
		if node.line and node.col
			warn(node.line, node.col, 3, msg)
		else
			error(msg)

	-- check type annotation
	var check_type = \tnode ->
		var rule = Type[tnode.tag]
		if rule
			rule(tnode)
	
	var check_types = \tnodes ->
		if tnodes
			for _, node in ipairs(tnodes)
				check_type(node)

	var check_stmts = \nodes ->
		for _, node in ipairs(nodes)
			var rule = Stmt[node.tag]
			if rule
				rule(node)
			else
				fail(node)

	var check_block = \nodes ->
		scope.enter()
		check_stmts(nodes)
		scope.leave()

	var infer_expr = \node ->
		var rule = Expr[node.tag]
		return rule(node)

	var infer_exprs = \nodes ->
		var types = {}
		for i, node in ipairs(nodes)
			types[i] = infer_expr(node)
		return types

	var declare = \var, vtype ->
		assert(var.tag == TExpr.Id)
		scope.new_var(var.name, vtype, var.line, var.col)


	var balance_check = \lefts, rights ->
		var r = #rights
		var l = #lefts
		if r > l
			warn(rights[1].line, rights[1].col, 1, "assigning " .. r .. " values to " .. l .. " variable(s)")

	--------- Types --------------------------
	Type[TType.Tuple] = \node ->
		check_types(node.types)
		
	Type[TType.Ref] = \node ->
		if node.params
		
		if node.tytys
			var vtypes = {}
			var keys = {}
			for i, vk in ipairs(node.tytys)
				var key = vk[2]
				if key
					var dup = 0
					if "string" == type(key) -- key can be string, or type desc
						for n = 1, #keys
							if "string" == type(keys[n]) and key == keys[n]
								dup = n
					else
						check_type(key)
						for n = 1, #keys
							if keys[n] and ast.same(keys[n], key)
								dup = n
					if dup > 0
						warn(key.line, key.col, 1, "duplicate key types at position " .. i .. " and " .. dup .. " in table type annotation")
				keys[i] = key
				
				var vt = vk[1]
				check_type(vt)
				if vt and not key
					for n = 1, #vtypes
						if vtypes[n] and ast.same(vtypes[n], vt)
							warn(vt.line, vt.col, 1, "similar value types at position " .. i .. " and " .. n .. " in table type annotation")
					vtypes[i] = vt
			
	
	--------- Expressions --------------------
	Expr[TExpr.Nil] = \node ->
		return ast.Type.nil(node)

	Expr[TExpr.Bool] = \node ->
		return ast.Type.bool(node)

	Expr[TExpr.Number] = \node ->
		return ast.Type.num(node)
		
	Expr[TExpr.String] = \node ->
		return ast.Type.str(node)
	
	Expr[TExpr.Vararg] = \node ->
		if not scope.is_varargs()
			warn(node.line, node.col, 2, "cannot use `...` in a function without variable arguments")
		var t = ast.Type.any(node) 
		ast.varargs(t)
		return t

	Expr[TExpr.Id] = \node ->
		var line, t
		if node.name  -- node.name can be nil, bcoz the parser continues despite error
			line, t = scope.declared(node.name)
			if line == 0
				warn(node.line, node.col, 1, "undeclared identifier `" .. node.name .. "`")
			if not t
				t = ast.Type.new(node)
		return t
		
	Expr[TExpr.Function] = \node ->
		scope.begin_func()
		check_types(node.types)
		check_types(node.retypes)
		for i, p in ipairs(node.params)
			var t = node.types and node.types[i] or ast.Type.new(p)
			if p.tag == TExpr.Vararg
				scope.varargs()
				ast.varargs(t)
			else
				declare(p, t)
		-- retypes can be null, means not set yet
		scope.set_returns(node.retypes)
		check_block(node.body)
		var ptypes = {}
		for i, p in ipairs(node.params)
			ptypes[i] = ty.apply(infer_expr(p))
			if node.types and node.types[i]
				ty.unify(ptypes[i], node.types[i])
				ptypes[i] = node.types[i]
		scope.end_func()
		return ast.Type.func(ast.Type.tuple(ptypes, node), ast.Type.tuple(scope.get_returns() or {}, node), node)

	Expr[TExpr.Table] = \node ->
		-- check for duplicate key
		var keys = {}
		for i, vk in ipairs(node.valkeys)
			var key = vk[2]
			if key
				for n = 1, #keys
					if keys[n] and ast.same(keys[n], key)
						warn(key.line, key.col, 10, "duplicate keys at position " .. i .. " and " .. n .. " in table")
			keys[i] = key

		-- type check
		var tytys = {}
		var vtyped = false
		var vtype
		for _, vk in ipairs(node.valkeys)
			var vt, kt
			vt = infer_expr(vk[1])
			kt = vk[2] and infer_expr(vk[2])
			if kt
				if kt.tag == TType.Val and kt.type == "str"
					-- take the string literal
					tytys[#tytys + 1] = { vt, vk[2].value }
				else
					tytys[#tytys + 1] = { vt, kt }
			else -- only set vtype if all vtypes are same
				if not vtyped
					vtyped = true
					vtype = vt
				else if not ast.same(vtype, vt)
					vtype = nil
		if vtype
			tytys[#tytys + 1] = { vtype, nil }
		var tbl = ast.Type.tbl(tytys, node)
		-- self check
		check_type(tbl)
		return tbl

	Expr[TExpr.Index] = \node ->
		var it, ot
		it = infer_expr(node.idx)
		-- if it is string, check
		-- else ot can be any type
			-- if index is number, it can be float, so we cannot know
			-- else index is its runtime value, so we cannot know
		ot = infer_expr(node.obj)
		ty.unify(ot, ast.Type.tbl({}, node.obj))
		return ast.Type.any(node)

	Expr[TExpr.Property] = \node ->
		var ot
		ot = infer_expr(node.obj)
		var vt = ast.Type.new(node.obj)
		var tytys = {
			{ vt, node.prop }
		}
		ty.unify(ot, ast.Type.tbl(tytys, node.obj))
		return ty.apply(vt)

	Expr[TExpr.Invoke] = \node ->
		var atypes, ot
		atypes = infer_exprs(node.args)
		ot = infer_expr(node.obj)
		var retype = ast.Type.new(node.obj)
		var tytys = {
			{ ast.Type.func(ast.Type.tuple(atypes, node), ast.Type.tuple({retype}, node.obj), node.obj), node.prop }
		}
		ty.unify(ot, ast.Type.tbl(tytys, node.obj))
		return ty.apply(retype)

	Expr[TExpr.Call] = \node ->
		var atypes, ftype
		atypes = infer_exprs(node.args)
		ftype = infer_expr(node.func)
		var retype = ast.Type.new(node.func)
		ty.unify(ftype, ast.Type.func(ast.Type.tuple(atypes, node), ast.Type.tuple({retype}, node.func), node))
		return ty.apply(retype)

	Expr[TExpr.Unary] = \node ->
		var rtype
		rtype = infer_expr(node.right)
		var op = node.op
		if op == '#'
			ty.unify(ast.Type.tbl({}, node), rtype)
			return ast.Type.num(node)
		if op == '-'
			ty.unify(ast.Type.num(node), rtype)
			return ast.Type.num(node)
		-- op == 'not'
		return ast.Type.bool(node)

	Expr[TExpr.Binary] = \node ->
		var rtype, ltype
		rtype = infer_expr(node.right)
		ltype = infer_expr(node.left)
		
		var op = node.op
		if op == 'and'
			return rtype

		if op == '+' or op == '-' or op == '*' or op == '/' or op == '^' or op == '>' or op == '>=' or op == '<' or op == '<=' or op == '==' or op == '..'
			ty.unify(rtype, ltype)
			if op == '>' or op == '>=' or op == '<' or op == '<=' or op == '=='
				return ast.Type.bool(node)
		-- op == 'or'
		return ltype


	--------- Statements --------------------
	Stmt[TStmt.Expr] = \node ->
		var etype
		etype = infer_expr(node.expr)

	Stmt[TStmt.Local] = \node ->
		check_types(node.types)
		balance_check(node.vars, node.exprs)
		var rtypes
		rtypes = infer_exprs(node.exprs)
		for i, var in ipairs(node.vars)
			var ltype = node.types and node.types[i]
			if ltype
				ty.unify(ltype, rtypes[i])
			else
				ltype = rtypes[i]
				if not ltype
					ltype = ast.Type.new(var)
					ast.nils(ltype)
			declare(var, ltype)

	Stmt[TStmt.Assign] = \node ->
		balance_check(node.lefts, node.rights)
		var rtypes, ltypes
		rtypes = infer_exprs(node.rights)
		ltypes = infer_exprs(node.lefts)
		for i, ltype in ipairs(ltypes)
			ty.unify(ltype, rtypes[i] or ast.Type.nil(node.rights[i] or ast.Expr.nil(node)))

	Stmt[TStmt.Do] = \node ->
		check_block(node.body)

	Stmt[TStmt.If] = \node ->
		for i = 1, #node.tests
			infer_expr(node.tests[i])
			check_block(node.thenss[i])
		if node.elses
			check_block(node.elses)

	Stmt[TStmt.Forin] = \node ->
		scope.enter_forin()
		check_types(node.types)
		var types
		types = infer_exprs(node.exprs)
		-- declare var into scope after rhs
		for i, var in ipairs(node.vars)
			declare(var, node.types and node.types[i])
		check_block(node.body)
		scope.leave()

	Stmt[TStmt.Fornum] = \node ->
		scope.enter_fornum()
		infer_expr(node.first)
		infer_expr(node.last)
		if node.step
			infer_expr(node.step)
		-- declare var into scope after rhs
		declare(node.var, ast.Type.num(node.var))
		check_block(node.body)
		scope.leave()

	Stmt[TStmt.While] = \node ->
		scope.enter_while()
		infer_expr(node.test)
		check_block(node.body)
		scope.leave()

	Stmt[TStmt.Repeat] = \node ->
		scope.enter_repeat()
		scope.enter()
		check_stmts(node.body)
		infer_expr(node.test)
		-- test expr in scope after `until`
		scope.leave()
		scope.leave()

	Stmt[TStmt.Return] = \node ->
		var types
		types = infer_exprs(node.exprs)
		var rtuple = scope.get_returns()
		if rtuple
			for i, r in ipairs(rtuple.types)
				if types[i]
					ty.unify(r, types[i])
		else
			-- not set before
			scope.set_returns(ast.Type.tuple(types, node))

	Stmt[TStmt.Break] = \node ->
		scope.new_break(node.line, node.col)

	Stmt[TStmt.Goto] = \node ->
		scope.new_goto(node.name, node.line, node.col)

	Stmt[TStmt.Label] = \node ->
		scope.new_label(node.name, node.line, node.col)


	-- main chunk is always a vararg function
	scope.begin_func()
	scope.varargs()
	check_block(stmts)
	scope.end_func()


