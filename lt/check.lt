var ty = require('lt.type')
var Tag = require('lt.tag')
var solve = require('lt.solve')
var TStmt = Tag.Stmt
var TExpr = Tag.Expr
var TType = Tag.Type


var relational = \op ->
	return op == '>' or op == '>=' or op == '<' or op == '<=' or op == '==' or op == '~='

var arithmetic = \op ->
	return op == '+' or op == '-' or op == '*' or op == '/' or op == '^'

return \scope, stmts, warn, import ->

	var Stmt = {}
	var Expr = {}
	var Type = {}
	var solv = solve()
	
	var id = 0
	var new = ->
		id = id + 1
		return { tag = TType.New, id = id }


	var fail = \node ->
		var msg = (node.tag or 'nil') .. " cannot match a statement type"
		if node.line and node.col
			warn(node.line, node.col, 3, msg)
		else
			error(msg)

	var check = \x, y, node, msg ->
		var t, err = solv.unify(x, y)
		if not t
			warn(node.line, node.col, 1, msg .. err)
		return t

	var check_op = \x, y, node, op ->
		return check(x, y, node, "operator `" .. op .. "` ")


	-- check type annotation
	var check_type = \tnode, loc ->
		var rule = Type[tnode.tag]
		if rule
			rule(tnode, loc)
	
	var check_types = \tnodes, loc ->
		if tnodes
			for _, node in ipairs(tnodes)
				check_type(node, loc)

	var check_stmts = \nodes ->
		for _, node in ipairs(nodes)
			var rule = Stmt[node.tag]
			if rule
				rule(node)
			else
				fail(node)

	var check_block = \nodes ->
		scope.enter()
		check_stmts(nodes)
		scope.leave()

	var infer_expr = \node ->
		var rule = Expr[node.tag]
		return rule(node)

	var infer_exprs = \nodes ->
		var types, t = {}, 0
		var last = #nodes
		for i, node in ipairs(nodes)
			var nt = infer_expr(node)
			if nt.tag == TType.Tuple
				if i == last
					for __, v in ipairs(nt)
						t = t + 1
						types[t] = v
				else
					t = t + 1
					types[t] = nt[1] or ty.nil()
			else
				t = t + 1
				types[t] = nt
		return types

	var declare = \var, vtype ->
		assert(var.tag == TExpr.Id)
		var name = var.name
		if name == '@'
			name = 'self'
		scope.new_var(name, vtype, var.line, var.col)

	var balance_check = \lefts, rights ->
		var r = #rights
		var l = #lefts
		if r > l
			warn(rights[1].line, rights[1].col, 1, "assigning " .. r .. " values to " .. l .. " variable(s)")

	--------- Types --------------------------
	Type[TType.Func] = \node, loc ->
		check_types(node.ins, loc)
		check_types(node.outs, loc)
		
	Type[TType.Tbl] = \node, loc ->
			var vtypes = {}
			var keys = {}
			for i, vk in ipairs(node)
				var key = vk[2]
				if key
					var dup = 0
					if "string" == type(key) -- key can be string, or type desc
						for n = 1, #keys
							if "string" == type(keys[n]) and key == keys[n]
								dup = n
					else
						check_type(key, loc)
						for n = 1, #keys
							if keys[n] and ty.same(keys[n], key)
								dup = n
					if dup > 0
						warn(loc.line, loc.col, 1, "duplicate key types at position " .. i .. " and " .. dup .. " in table type annotation")
				keys[i] = key
				
				var vt = vk[1]
				check_type(vt, loc)
				if vt and not key
					for n = 1, #vtypes
						if vtypes[n] and ty.same(vtypes[n], vt)
							warn(loc.line, loc.col, 1, "similar value types at position " .. i .. " and " .. n .. " in table type annotation")
					vtypes[i] = vt
			
	
	--------- Expressions --------------------
	Expr[TExpr.Nil] = ->
		return ty.nil()

	Expr[TExpr.Bool] = ->
		return ty.bool()

	Expr[TExpr.Number] = ->
		return ty.num()
		
	Expr[TExpr.String] = ->
		return ty.str()
	
	Expr[TExpr.Vararg] = \node ->
		if not scope.is_varargs()
			warn(node.line, node.col, 2, "cannot use `...` in a function without variable arguments")
		return ty.any_vars()

	Expr[TExpr.Id] = \node ->
		var line, t
		if node.name  -- node.name can be nil, bcoz the parser continues despite error
			var name = node.name
			if name == '@'
				name = 'self'
			line, t = scope.declared(name)
			if line == 0
				warn(node.line, node.col, 1, "undeclared identifier `" .. node.name .. "`")
			if not t
				t = new()
		return t
		
	Expr[TExpr.Function] = \node ->
		scope.begin_func()
		check_types(node.types, node)
		check_types(node.retypes, node)

		var ptypes = {}
		for i, p in ipairs(node.params)
			var t = node.types and node.types[i] or new()
			if p.tag == TExpr.Vararg
				scope.varargs()
				t = ty.varargs(t)
			else
				declare(p, t)
			ptypes[i] = t
				
		-- retypes can be null, means no annotation
		scope.set_returns(node.retypes)
		check_block(node.body)
		
		-- check parameter usage
		var anno = node.types
		if anno
			for i, p in ipairs(node.params)
				if anno[i]
					check(infer_expr(p), anno[i], p, "parameter " .. (p.tag == TExpr.Vararg and "..." or p.name) .. " ")

		var rtuple = scope.get_returns() or ty.tuple_none()
		scope.end_func()
		return ty.func(ty.tuple(ptypes), rtuple)

	Expr[TExpr.Table] = \node ->
		-- check for duplicate key
		var keys = {}
		for i, vk in ipairs(node.valkeys)
			var key = vk[2]
			if key
				for n = 1, #keys
					if keys[n] and ty.same(keys[n], key)
						warn(key.line, key.col, 10, "duplicate keys at position " .. i .. " and " .. n .. " in table")
			keys[i] = key

		-- type check
		var tytys = {}
		var vtyped = false
		var vtype
		for _, vk in ipairs(node.valkeys)
			var vt, kt
			vt = infer_expr(vk[1])
			kt = vk[2] and infer_expr(vk[2])
			if kt
				if kt.tag == TType.Val and kt.type == "str"
					-- take the string literal
					tytys[#tytys + 1] = { vt, vk[2].value }
				else
					tytys[#tytys + 1] = { vt, kt }
			else -- only set vtype if all vtypes are same
				if not vtyped
					vtyped = true
					vtype = vt
				else if not ty.same(vtype, vt)
					vtype = nil
		if vtype
			tytys[#tytys + 1] = { vtype, nil }
		var tbl = ty.tbl(tytys)
		return tbl

	Expr[TExpr.Index] = \node ->
		var it = infer_expr(node.idx)
		-- if index type is string, check
		-- else key index can be any type
			-- if index is number, it can be float, so we cannot know
			-- else index is its runtime value, so we cannot know
		var ot = infer_expr(node.obj)
		check(ty.tbl({}), ot, node, "indexer ")
		return ty.any(), ot

	Expr[TExpr.Field] = \node ->
		var ot = infer_expr(node.obj)
		if check(ty.tbl({}), ot, node, "field `." .. node.field .. "` ")
			var t = solv.apply(ot)
			var tbl = ty.get_tbl(t)
			if tbl
				for _, tk in ipairs(tbl)
					if tk[2] == node.field
						return tk[1], t
				-- key doesnt exist
				var vt = new()
				tbl[#tbl + 1] = { vt, node.field }
				return vt, t
			return ty.any(), t
		return ty.nil()

	Expr[TExpr.Call] = \node ->
		var arg1 = node.args[1]
		-- check imports
		if arg1 and arg1.tag == TExpr.String and node.func.tag == TExpr.Id and node.func.name == 'require'
				return import(arg1.value) or ty.any()

		var atypes
		var func = node.func
		var ftype, fobj = infer_expr(func)
		if arg1 and arg1.name == '@' and not func.bracketed
				if func.tag == TExpr.Field or func.tag == TExpr.Index
					atypes = { fobj }
					for i = 2, #node.args
						atypes[i] = infer_expr(node.args[i])
		
		if not atypes
			atypes = infer_exprs(node.args)
		var fn = solv.apply(ftype)
		if fn.tag == TType.Nil or fn.tag == TType.Val
			warn(node.line, node.col, 1, "trying to call " .. ty.tostr(fn))
		else if fn.tag == TType.New
			solv.extend(fn, ty.func(ty.tuple(atypes), ty.tuple_any()))
		else
			-- check params to args
			check(fn, ty.func(ty.tuple(atypes), ty.tuple_any()), node, "function ")
			if fn.outs
				return fn.outs
		return ty.tuple_any()

	Expr[TExpr.Unary] = \node ->
		var rtype = infer_expr(node.right)
		var op = node.op
		if op == '#'
			check_op(ty.or(ty.tbl({}), ty.str()), rtype, node, op)
			return ty.num()
		if op == '-'
			check_op(ty.num(), rtype, node, op)
			return ty.num()
		-- op == 'not'
		return ty.bool()

	Expr[TExpr.Binary] = \node ->
		var ltype = infer_expr(node.left)
		var rtype = infer_expr(node.right)
		
		var op = node.op
		if op == 'and'
			return rtype

		if arithmetic(op) or relational(op)
			-- skip equal and not equal, coz they can compare anything
			if op ~= '==' and op ~= '~='
				check_op(ltype, rtype, node, op)
			if relational(op)
				return ty.bool()
		else if op == '..'
			var strnum = ty.or(ty.num(), ty.str())
			check_op(strnum, rtype, node, op)
			check_op(strnum, ltype, node, op)
			return ty.str()
		-- op == 'or'
		return ltype


	Expr[TExpr.Union] = \node ->
		return ty.any()
		
	--------- Statements --------------------
	Stmt[TStmt.Expr] = \node ->
		var etype
		etype = infer_expr(node.expr)

	Stmt[TStmt.Local] = \node ->
		check_types(node.types, node)
		balance_check(node.vars, node.exprs)
		var rtypes
		rtypes = infer_exprs(node.exprs)
		for i, var in ipairs(node.vars)
			var ltype = node.types and node.types[i]
			if ltype and rtypes[i]
				check(ltype, rtypes[i], node, "type annotation ")
			declare(var, solv.extend(new(), ltype or rtypes[i] or ty.nil()))

	var assign = \nodes, types ->
		for i, node in ipairs(nodes)
			var rtype = types[i] or ty.or(ty.any(), ty.nil())
			var ltype
			if node.tag == TExpr.Id
				ltype = infer_expr(node)
				-- warn if reassignment of different type
				-- check(ltype, rtype, node, "assigment ")
				if not solv.unify(ltype, rtype, true)
					solv.extend(ltype, ty.or(solv.apply(ltype), rtype))
			else
				var ot = infer_expr(node.obj)
				if check(ty.tbl({}), ot, node, "assignment ")
					if node.tag == TExpr.Index
						var it = infer_expr(node.idx)
					else
						assert(node.tag == TExpr.Field)
						var tytys = {
							{ rtype, node.field }
						}
						var ok = solv.unify(ty.tbl(tytys), ot, true)
						if not ok
							var t = solv.apply(ot)
							var tbl = ty.get_tbl(t)
							if tbl
								for _, tk in ipairs(tbl)
									if tk[2] == node.field
										-- reassignment of different type to same field
										tk[1] = ty.or(tk[1], rtype)
										solv.extend(ot, t)
										return
								
								-- add a new field if it is posibly a parameter name
								-- so that for f: t1 -> t2,  t2 is different from t1
								var param = node.obj.name
								if param
									if param == '@'
										param = 'self'
									t = ty.clone(t)
									tbl = ty.get_tbl(t)
									tbl[#tbl + 1] = tytys[1]
									assert(scope.update_var(param, solv.extend(new(), t)))
								-- else need to find the tvar to extend, which we cant bcoz we are next next level down


	Stmt[TStmt.Assign] = \node ->
		balance_check(node.lefts, node.rights)
		var rtypes = infer_exprs(node.rights)
		assign(node.lefts, rtypes)

	Stmt[TStmt.Do] = \node ->
		check_block(node.body)

	Stmt[TStmt.If] = \node ->
		for i = 1, #node.tests
			infer_expr(node.tests[i])
			check_block(node.thenss[i])
		if node.elses
			check_block(node.elses)

	Stmt[TStmt.Forin] = \node ->
		scope.enter_forin()
		check_types(node.types, node)
		infer_exprs(node.exprs)
		-- declare var into scope after rhs
		for i, var in ipairs(node.vars)
			declare(var, node.types and node.types[i])
		check_block(node.body)
		scope.leave()

	Stmt[TStmt.Fornum] = \node ->
		scope.enter_fornum()
		var msg = " expression in numeric for "
		check(ty.num(), infer_expr(node.first), node, "first " .. msg)
		check(ty.num(), infer_expr(node.last), node, "second " .. msg)
		if node.step
			check(ty.num(), infer_expr(node.step), node, "third " .. msg)
		-- declare var into scope after rhs
		declare(node.var, ty.num())
		check_block(node.body)
		scope.leave()

	Stmt[TStmt.While] = \node ->
		scope.enter_while()
		infer_expr(node.test)
		check_block(node.body)
		scope.leave()

	Stmt[TStmt.Repeat] = \node ->
		scope.enter_repeat()
		scope.enter()
		check_stmts(node.body)
		infer_expr(node.test)
		-- test expr in scope after `until`
		scope.leave()
		scope.leave()

	Stmt[TStmt.Return] = \node ->
		var now = ty.tuple(infer_exprs(node.exprs))
		var prev = scope.get_returns()
		if prev
			now = ty.or(prev, now)
		scope.set_returns(now)

	Stmt[TStmt.Break] = \node ->
		scope.new_break(node.line, node.col)

	Stmt[TStmt.Goto] = \node ->
		scope.new_goto(node.name, node.line, node.col)

	Stmt[TStmt.Label] = \node ->
		scope.new_label(node.name, node.line, node.col)


	-- main chunk is always a vararg function
	scope.begin_func()
	scope.varargs()
	check_block(stmts)
	var rtuple = scope.get_returns()
	scope.end_func()
	-- lua require() can only return single value
	if rtuple and rtuple[1]
		return solv.apply(rtuple[1])
	return ty.nil()


