var ty = require('lt.type')
var Tag = require('lt.tag')
var solve = require('lt.solve')
var TStmt = Tag.Stmt
var TExpr = Tag.Expr
var TType = Tag.Type


var relational = \op ->
	return op == '>' or op == '>=' or op == '<' or op == '<=' or op == '==' or op == '~='

var arithmetic = \op ->
	return op == '+' or op == '-' or op == '*' or op == '/' or op == '^'

return \scope, stmts, warn, import ->

	var Stmt = {}
	var Expr = {}
	var Type = {}
	var solv = solve()
	
	var id = 0
	var new = ->
		id = id + 1
		return { tag = TType.New, id = id }


	var fail = \node ->
		var msg = (node.tag or 'nil') .. " cannot match a statement type"
		if node.line and node.col
			warn(node.line, node.col, 3, msg)
		else
			error(msg)

	var check = \x, y, node, msg ->
		var t, err = solv.unify(x, y)
		if not t
			warn(node.line, node.col, 1, msg .. err)

	var check_op = \x, y, node, op ->
		check(x, y, node, "operator `" .. op .. "` ")


	-- check type annotation
	var check_type = \tnode, loc ->
		var rule = Type[tnode.tag]
		if rule
			rule(tnode, loc)
	
	var check_types = \tnodes, loc ->
		if tnodes
			for _, node in ipairs(tnodes)
				check_type(node, loc)

	var check_stmts = \nodes ->
		for _, node in ipairs(nodes)
			var rule = Stmt[node.tag]
			if rule
				rule(node)
			else
				fail(node)

	var check_block = \nodes ->
		scope.enter()
		check_stmts(nodes)
		scope.leave()

	var infer_expr = \node ->
		var rule = Expr[node.tag]
		return rule(node)

	var infer_exprs = \nodes ->
		var types = {}
		for i, node in ipairs(nodes)
			types[i] = infer_expr(node)
		return types

	var declare = \var, vtype ->
		assert(var.tag == TExpr.Id)
		scope.new_var(var.name, vtype, var.line, var.col)

	var balance_check = \lefts, rights ->
		var r = #rights
		var l = #lefts
		if r > l
			warn(rights[1].line, rights[1].col, 1, "assigning " .. r .. " values to " .. l .. " variable(s)")

	--------- Types --------------------------
	Type[TType.Func] = \node, loc ->
		check_types(node.ins, loc)
		check_types(node.outs, loc)
		
	Type[TType.Tbl] = \node, loc ->
			var vtypes = {}
			var keys = {}
			for i, vk in ipairs(node)
				var key = vk[2]
				if key
					var dup = 0
					if "string" == type(key) -- key can be string, or type desc
						for n = 1, #keys
							if "string" == type(keys[n]) and key == keys[n]
								dup = n
					else
						check_type(key, loc)
						for n = 1, #keys
							if keys[n] and ty.same(keys[n], key)
								dup = n
					if dup > 0
						warn(loc.line, loc.col, 1, "duplicate key types at position " .. i .. " and " .. dup .. " in table type annotation")
				keys[i] = key
				
				var vt = vk[1]
				check_type(vt, loc)
				if vt and not key
					for n = 1, #vtypes
						if vtypes[n] and ty.same(vtypes[n], vt)
							warn(loc.line, loc.col, 1, "similar value types at position " .. i .. " and " .. n .. " in table type annotation")
					vtypes[i] = vt
			
	
	--------- Expressions --------------------
	Expr[TExpr.Nil] = ->
		return ty.nil()

	Expr[TExpr.Bool] = ->
		return ty.bool()

	Expr[TExpr.Number] = ->
		return ty.num()
		
	Expr[TExpr.String] = ->
		return ty.str()
	
	Expr[TExpr.Vararg] = \node ->
		if not scope.is_varargs()
			warn(node.line, node.col, 2, "cannot use `...` in a function without variable arguments")
		return ty.varargs(ty.any())

	Expr[TExpr.Id] = \node ->
		var line, t
		if node.name  -- node.name can be nil, bcoz the parser continues despite error
			line, t = scope.declared(node.name)
			if line == 0
				warn(node.line, node.col, 1, "undeclared identifier `" .. node.name .. "`")
			if not t
				t = new()
		return t
		
	Expr[TExpr.Function] = \node ->
		scope.begin_func()
		check_types(node.types, node)
		check_types(node.retypes, node)

		var ptypes = {}
		for i, p in ipairs(node.params)
			var t = node.types and node.types[i] or new()
			if p.tag == TExpr.Vararg
				scope.varargs()
				t = ty.varargs(t)
			else
				declare(p, t)
			ptypes[i] = t
				
		-- retypes can be null, means no annotation
		scope.set_returns(node.retypes)
		check_block(node.body)
		
		-- check parameter usage
		var anno = node.types
		if anno
			for i, p in ipairs(node.params)
				if anno[i]
					check(infer_expr(p), anno[i], p, "parameter " .. (p.tag == TExpr.Vararg and "..." or p.name) .. " ")

		var retuples = scope.get_returns()
		scope.end_func()
		return ty.func(ty.tuple(ptypes), retuples or ty.tuple({}))

	Expr[TExpr.Table] = \node ->
		-- check for duplicate key
		var keys = {}
		for i, vk in ipairs(node.valkeys)
			var key = vk[2]
			if key
				for n = 1, #keys
					if keys[n] and ty.same(keys[n], key)
						warn(key.line, key.col, 10, "duplicate keys at position " .. i .. " and " .. n .. " in table")
			keys[i] = key

		-- type check
		var tytys = {}
		var vtyped = false
		var vtype
		for _, vk in ipairs(node.valkeys)
			var vt, kt
			vt = infer_expr(vk[1])
			kt = vk[2] and infer_expr(vk[2])
			if kt
				if kt.tag == TType.Val and kt.type == "str"
					-- take the string literal
					tytys[#tytys + 1] = { vt, vk[2].value }
				else
					tytys[#tytys + 1] = { vt, kt }
			else -- only set vtype if all vtypes are same
				if not vtyped
					vtyped = true
					vtype = vt
				else if not ty.same(vtype, vt)
					vtype = nil
		if vtype
			tytys[#tytys + 1] = { vtype, nil }
		var tbl = ty.tbl(tytys)
		return tbl

	Expr[TExpr.Index] = \node ->
		var it, ot
		it = infer_expr(node.idx)
		-- if index type is string, check
		-- else key index can be any type
			-- if index is number, it can be float, so we cannot know
			-- else index is its runtime value, so we cannot know
		ot = infer_expr(node.obj)
		check(ty.tbl({}), ot, node, "indexer ")
		return ty.any()

	Expr[TExpr.Field] = \node ->
		var ot
		ot = infer_expr(node.obj)
		var vt = new()
		var tytys = {
			{ vt, node.field }
		}
		check(ty.tbl(tytys), ot, node, "field `." .. node.field .. "` ")
		return vt

	Expr[TExpr.Invoke] = \node ->
		var atypes, ot
		atypes = infer_exprs(node.args)
		ot = infer_expr(node.obj)
		var retype = new()
		var tytys = {
			{ ty.func(ty.tuple(atypes), ty.tuple({retype})), node.field }
		}
		check(ty.tbl(tytys), ot, node, "method `" .. node.field .. "` ")
		return retype

	Expr[TExpr.Call] = \node ->
		var atypes, ftype
		atypes = infer_exprs(node.args)
		-- check imports
		if node.func.tag == TExpr.Id and node.func.name == 'require'
			return import(node.args[1].value) or ty.nil()

		ftype = infer_expr(node.func)
		var retype = new()
		check(ftype, ty.func(ty.tuple(atypes), ty.tuple({retype})), node, "function ")
		return retype

	Expr[TExpr.Unary] = \node ->
		var rtype
		rtype = infer_expr(node.right)
		var op = node.op
		if op == '#'
			check_op(ty.or(ty.tbl({}), ty.str()), rtype, node, op)
			return ty.num()
		if op == '-'
			check_op(ty.num(), rtype, node, op)
			return ty.num()
		-- op == 'not'
		return ty.bool()

	Expr[TExpr.Binary] = \node ->
		var ltype, rtype
		ltype = infer_expr(node.left)
		rtype = infer_expr(node.right)
		
		var op = node.op
		if op == 'and'
			return rtype

		if arithmetic(op) or relational(op)
			check_op(ltype, rtype, node, op)
			if relational(op)
				return ty.bool()
		else if op == '..'
			var strnum = ty.or(ty.num(), ty.str())
			check_op(strnum, rtype, node, op)
			check_op(strnum, ltype, node, op)
			return ty.str()
		-- op == 'or'
		return ltype


	--------- Statements --------------------
	Stmt[TStmt.Expr] = \node ->
		var etype
		etype = infer_expr(node.expr)

	Stmt[TStmt.Local] = \node ->
		check_types(node.types, node)
		balance_check(node.vars, node.exprs)
		var rtypes
		rtypes = infer_exprs(node.exprs)
		for i, var in ipairs(node.vars)
			var ltype = node.types and node.types[i]
			if ltype and rtypes[i]
				check(ltype, rtypes[i], node, "type annotation ")
			declare(var, solv.extend(new(), ltype or rtypes[i] or ty.nil()))

	var assign = \nodes, types ->
		for i, node in ipairs(nodes)
			var rtype = types[i] or ty.or(ty.any(), ty.nil())
			var ltype
			if node.tag == TExpr.Id
				ltype = infer_expr(node)
				-- warn if reassignment of different type
				-- check(ltype, rtype, node, "assigment ")
				if not solv.unify(ltype, rtype, true)
					solv.extend(ltype, ty.or(solv.apply(ltype), rtype))
			else
				var ot = infer_expr(node.obj)
				-- ot must be table
				check(ty.tbl({}), ot, node, " assignment ")
				if node.tag == TExpr.Index
					var it = infer_expr(node.idx)
				else
					assert(node.tag == TExpr.Field)
					var vt = new()
					var tytys = {
						{ vt, node.field }
					}
					var t = solv.unify(ty.tbl(tytys), ot, true)
					if t
						solv.extend(vt, rtype)
					else
						if t == nil  -- adding new key
							scope.update_var(node.obj.name, solv.extend(new(), ty.tbl(tytys)))
						else -- reassignment of different type
							solv.extend(vt, ty.or(solv.apply(vt), rtype))


	Stmt[TStmt.Assign] = \node ->
		balance_check(node.lefts, node.rights)
		var rtypes = infer_exprs(node.rights)
		assign(node.lefts, rtypes)

	Stmt[TStmt.Do] = \node ->
		check_block(node.body)

	Stmt[TStmt.If] = \node ->
		for i = 1, #node.tests
			infer_expr(node.tests[i])
			check_block(node.thenss[i])
		if node.elses
			check_block(node.elses)

	Stmt[TStmt.Forin] = \node ->
		scope.enter_forin()
		check_types(node.types, node)
		var types
		types = infer_exprs(node.exprs)
		-- declare var into scope after rhs
		for i, var in ipairs(node.vars)
			declare(var, node.types and node.types[i])
		check_block(node.body)
		scope.leave()

	Stmt[TStmt.Fornum] = \node ->
		scope.enter_fornum()
		infer_expr(node.first)
		infer_expr(node.last)
		if node.step
			infer_expr(node.step)
		-- declare var into scope after rhs
		declare(node.var, ty.num())
		check_block(node.body)
		scope.leave()

	Stmt[TStmt.While] = \node ->
		scope.enter_while()
		infer_expr(node.test)
		check_block(node.body)
		scope.leave()

	Stmt[TStmt.Repeat] = \node ->
		scope.enter_repeat()
		scope.enter()
		check_stmts(node.body)
		infer_expr(node.test)
		-- test expr in scope after `until`
		scope.leave()
		scope.leave()

	Stmt[TStmt.Return] = \node ->
		var types
		types = infer_exprs(node.exprs)
		var rtuple = scope.get_returns()
		if rtuple
			for i, r in ipairs(rtuple)
				if types[i]
					check(r, types[i], node.exprs[i] or node, "return type ")
		else
			-- not set before
			scope.set_returns(ty.tuple(types))

	Stmt[TStmt.Break] = \node ->
		scope.new_break(node.line, node.col)

	Stmt[TStmt.Goto] = \node ->
		scope.new_goto(node.name, node.line, node.col)

	Stmt[TStmt.Label] = \node ->
		scope.new_label(node.name, node.line, node.col)


	-- main chunk is always a vararg function
	scope.begin_func()
	scope.varargs()
	check_block(stmts)
	var rtuple = scope.get_returns()
	scope.end_func()
	-- lua require() can only return single value
	if rtuple
		return solv.apply(rtuple[1])
	

