var read = require('lua.read')
var lex = require('lua.lex')
var scope = require('lua.scope')
var parse = require('lua.parse')
var check = require('lua.check')
var transform = require('lua.transform')
var generate = require('lua.generate')

--`
options is a table:
 options = {
    declares = {ngx = true, xvars = true, ...}
    , silent = {...}
 }
 color is a table of ansi color values to display warnings
--`
var compile = \reader, options, color ->
	
	-- array of warnings, ordered by line,col
	-- must be local, so that repl warnings are cleared
	var warnings = {}

	var warn = \line, col, severity, msg ->
		var w = { line = line, col = col, severity = severity, msg = msg }
		
		for i, m in ipairs(warnings)
			-- skip errors at the same line with lower severity
			if line == m.line and severity < m.severity -- and col == m.col and msg == m.msg
				return
			if line < m.line or (line == m.line and col < m.col)
				-- insert
				table.insert(warnings, i, w)
				return
		-- append
		table.insert(warnings, w)

	-- convert to colored text
	var warning = ->
		var warns = {}
		for i, m in ipairs(warnings)
			var clr = color.yellow
			if m.severity > 2
				clr = color.red
			else if m.severity > 1
				clr = color.magenta
			warns[i] = string.format(" %d,%d:" .. clr ..  "  %s" .. color.reset, m.line, m.col, m.msg)
		if #warns > 0
			return table.concat(warns, "\n")

	-- severity > 2 means its likely to crash the next stage
	var continue = ->
		for _, w in ipairs(warnings)
			if w.severity > 2
				return false
		return true

	var lexer = lex(reader, warn)
	if continue()
		var tree = parse(lexer, warn)
		if continue()
			tree = transform(tree)
			if continue()
				var sc = scope(options.declares, warn)
				check(sc, tree, warn)
				if continue()
					return generate(tree), warning(color)

	return nil, warning(color)


return {
	string = \src, options, color ->
		return compile(read.string(src), options or {}, color)
	
	, file = \filename, options, color ->
		return compile(read.file(filename), options or {}, color)
}
