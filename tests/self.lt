var se = {}

se.q = \@ ->


assert(se.q() == nil)

se.x = \@, line ->
	var a = 1
	var b = 2
	return a + b

assert(se.x() == 3)

var adds = \t, v ->
	return (t[1] or 1) + v

se[1] = 10

-- make sure normal function taking self still works
se.emit = \@, val ->
	var a = adds(self, val)
	return a

assert(se.emit(se, 10) == 20)
assert(se.emit(@, 10) == 20)
assert(se.emit({3}, 10) == 13)

-- reverse self and @
se.emit2 = \self, val ->
	var a = adds(@, val)
	return a

assert(se.emit2(se, 10) == 20)
assert(se.emit2(@, 10) == 20)
assert(se.emit2({3}, 10) == 13)


-- string method
assert(("hi").rep(@, 3) == "hihihi")
assert(("hi").rep("Hello! ", 3) == "Hello! Hello! Hello! ")


-- objects
var met = \@, k-> return k * self.value

var obj = { value = 3, met = met }
assert(obj.met(@, 2) == 6)


var foo = \@, k-> return k * @.value

var create = \x-> return { value = x, foo = foo }

print(create(3.141592).foo(@, 2))


var inline = { value = 3.141592, foo = \@, i-> return i*@.value }
print(inline.foo(@, 2))


-- @ should just works

var t = {num = 10}
t['h-a'] = \@, n ->
	return @.num + n

assert(t['h-a'](@, 40) == 50)
var ret_t = ->
	return t
print(ret_t()['h-a'](@, 10) == 20)


-- self and @ is interchangeable

var boo = { value = 7, compute= \self, i-> return self.value*i+1 }
print(boo.compute(@, 3) + boo.compute(@, 7))


-- self is not keyword
var self = 8
